<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《Substrate Docs》翻译 3.4 Runtime Development - Storage | 天了噜Rex的杂物堆</title><meta name="keywords" content="翻译"><meta name="author" content="天了噜Rex"><meta name="copyright" content="天了噜Rex"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="存储（Storage）运行时存储允许您在区块链中存储数据，这些数据在块之间持久保存，并且可以从运行时逻辑中访问。 存储应该是区块链运行时开发人员最关心的问题之一。 设计良好的存储系统可以减少网络中节点的负载，从而最终降低区块链参与者的间接成本。 换句话说，区块链运行时存储的基本原则是尽量减少其使用。  Substrate 公开了一组分层的、模块化的存储 API，允许运行时开发人员做出最适合他们的存">
<meta property="og:type" content="article">
<meta property="og:title" content="《Substrate Docs》翻译 3.4 Runtime Development - Storage">
<meta property="og:url" content="http://example.com/2022/01/27/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%203.4%20Runtime%20Development%20-%20Storage/index.html">
<meta property="og:site_name" content="天了噜Rex的杂物堆">
<meta property="og:description" content="存储（Storage）运行时存储允许您在区块链中存储数据，这些数据在块之间持久保存，并且可以从运行时逻辑中访问。 存储应该是区块链运行时开发人员最关心的问题之一。 设计良好的存储系统可以减少网络中节点的负载，从而最终降低区块链参与者的间接成本。 换句话说，区块链运行时存储的基本原则是尽量减少其使用。  Substrate 公开了一组分层的、模块化的存储 API，允许运行时开发人员做出最适合他们的存">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png">
<meta property="article:published_time" content="2022-01-26T17:43:01.000Z">
<meta property="article:modified_time" content="2022-03-04T00:55:36.973Z">
<meta property="article:author" content="天了噜Rex">
<meta property="article:tag" content="翻译">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/01/27/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%203.4%20Runtime%20Development%20-%20Storage/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《Substrate Docs》翻译 3.4 Runtime Development - Storage',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-04 08:55:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">天了噜Rex的杂物堆</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《Substrate Docs》翻译 3.4 Runtime Development - Storage</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-01-26T17:43:01.000Z" title="Created 2022-01-27 01:43:01">2022-01-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-03-04T00:55:36.973Z" title="Updated 2022-03-04 08:55:36">2022-03-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E3%80%8ASubstrate-Docs%E3%80%8B%E7%BF%BB%E8%AF%91/">《Substrate Docs》翻译</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《Substrate Docs》翻译 3.4 Runtime Development - Storage"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="存储（Storage）"><a href="#存储（Storage）" class="headerlink" title="存储（Storage）"></a>存储（Storage）</h1><p>运行时存储允许您在区块链中存储数据，这些数据在块之间持久保存，并且可以从运行时逻辑中访问。 存储应该是区块链运行时开发人员最关心的问题之一。 设计良好的存储系统可以减少网络中节点的负载，从而最终降低区块链参与者的间接成本。 换句话说，区块链运行时存储的基本原则是尽量减少其使用。 </p>
<p>Substrate 公开了一组分层的、模块化的存储 API，允许运行时开发人员做出最适合他们的存储决策。 本文档旨在提供有关 Substrate 的运行时存储接口的信息和最佳实践。 有关如何实现这些接口的信息，请参阅[高级存储文档](<a target="_blank" rel="noopener" href="https://docs.substrate.io/v3/advanced/storage/">Storage | Substrate_</a>)。 </p>
<h2 id="存储项（Storage-items）"><a href="#存储项（Storage-items）" class="headerlink" title="存储项（Storage items）"></a>存储项（Storage items）</h2><p>在 Substrate 中，任何托盘都可以引入新的存储项目，这些项目将成为区块链状态的一部分。 这些存储项可以是简单的单值项，也可以是更复杂的存储映射。 您选择实现的存储项类型完全取决于它们在运行时逻辑中的预期角色。 </p>
<p>FRAME 的[<code>存储</code>模块](<a target="_blank" rel="noopener" href="https://paritytech.github.io/substrate/latest/frame_support/storage/">frame_support::storage - Rust (paritytech.github.io)</a>)使运行时开发人员可以访问 Substrate 的灵活存储 API，它可以支持 [SCALE 编解码器](<a target="_blank" rel="noopener" href="https://docs.substrate.io/v3/advanced/scale-codec/">SCALE Codec | Substrate_</a>)可编码的任何值。 这些包括： </p>
<ul>
<li>[Storage Value](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.StorageValue.html">StorageValue in frame_support::storage - Rust (substrate.io)</a>) - 用于存储任何单个值，例如 u64。 </li>
<li><a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.StorageMap.html">Storage Map</a> - 用于存储键值映射，例如帐户到余额。 </li>
<li><a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.StorageDoubleMap.html">Storage Double Map</a> - 用作具有两个键的存储映射的实现，以提供有效删除具有公共第一个键的所有条目的能力。 </li>
<li><a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.StorageNMap.html">Storage N Map</a> - 用于存储任意数量的key的映射，可以作为基础构建Triple Storage Map、Quadruple Storage Map等。 </li>
</ul>
<h3 id="存储值（Storage-value）"><a href="#存储值（Storage-value）" class="headerlink" title="存储值（Storage value）"></a>存储值（Storage value）</h3><p>这种类型的存储项应该用于运行时视为单个单元的值。 这可以是单个原始值、单个<code>结构体</code>或相关项的单个集合。 如果存储项用于存储项列表，则运行时开发人员应该注意他们使用的列表的大小。 大型列表会产生存储成本，就像大型<code>结构体</code>一样。 此外，在您的运行时迭代一个大列表可能会导致超过块生产时间。 如果主权链发生这种情况，区块链将减速。 如果[平行链](<a target="_blank" rel="noopener" href="https://docs.substrate.io/v3/getting-started/glossary/#parachain">Glossary | Substrate_</a>)发生这种情况，区块链将停止生成块并停止运行。 </p>
<blockquote>
<p><strong>重要信息</strong></p>
<p>尽管将相关项目包装在共享<code>结构体</code>中是减少存储读取次数的绝佳方法，但在某些时候，对象的大小将开始产生可能超过存储读取优化的成本。 阅读有关[基准测试](<a target="_blank" rel="noopener" href="https://docs.substrate.io/v3/runtime/benchmarking/">Benchmarking | Substrate_</a>)的更多信息，以了解如何优化执行时间。 </p>
</blockquote>
<p>有关 [Storage Value 公开的方法的完整列表](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.StorageValue.html#required-methods">StorageValue in frame_support::storage - Rust (substrate.io)</a>)，请参阅 Storage Value 文档。 </p>
<h3 id="存储映射（Storage-map）"><a href="#存储映射（Storage-map）" class="headerlink" title="存储映射（Storage map）"></a>存储映射（Storage map）</h3><p>映射数据结构非常适合管理其元素将被随机访问的项目集，而不是按顺序对它们进行整体迭代。 Substrate 中的存储映射被实现为键值映射，它提供与传统<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hash_table">哈希映射</a>类似的接口以实现随机查找。 为了给运行时工程师更多的控制权，Substrate 允许开发人员选择最适合他们用例的哈希算法来生成映射的键。 这在关于[散列算法](<a target="_blank" rel="noopener" href="https://docs.substrate.io/v3/runtime/storage/#hashing-algorithms">Storage | Substrate_</a>)的部分中进行了介绍。 </p>
<p>有关 [Storage Map 公开的方法的完整列表](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.StorageMap.html#required-methods">StorageMap in frame_support::storage - Rust (substrate.io)</a>)，请参阅 Storage Map 文档。 </p>
<h3 id="双存储映射（Double-storage-map）"><a href="#双存储映射（Double-storage-map）" class="headerlink" title="双存储映射（Double storage map）"></a>双存储映射（Double storage map）</h3><p>[双存储映射](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.StorageDoubleMap.html">StorageDoubleMap in frame_support::storage - Rust (substrate.io)</a>)与单存储映射非常相似，只是它们包含两个键，这对于使用公共键查询值很有用。  </p>
<p>请参阅有关[高级存储](<a target="_blank" rel="noopener" href="https://docs.substrate.io/v3/advanced/storage/">Storage | Substrate_</a>)的文档，以了解有关如何实现不同存储映射（包括双存储映射）的更多信息。 </p>
<h3 id="N存储映射（N-storage-map）"><a href="#N存储映射（N-storage-map）" class="headerlink" title="N存储映射（N storage map）"></a>N存储映射（N storage map）</h3><p>N Storage Maps 也非常类似于它的兄弟，即 Storage Maps 和 Double Storage Maps，但能够保存任意数量的键。 </p>
<p>要在 FRAMEv2 中指定 N 存储映射中的键，在声明 <code>StorageNMap</code> 时，必须将包含特殊 <code>NMapKey</code> 结构的元组作为键（即第二个）类型参数的类型提供。 </p>
<p>有关使用 N Storage Map 的语法的更多详细信息，请参阅 [N Storage Map 文档](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.StorageNMap.html">StorageNMap in frame_support::storage - Rust (substrate.io)</a>)。 </p>
<h3 id="迭代存储映射（Iterating-over-Storage-Maps）"><a href="#迭代存储映射（Iterating-over-Storage-Maps）" class="headerlink" title="迭代存储映射（Iterating over Storage Maps）"></a>迭代存储映射（Iterating over Storage Maps）</h3><p>Substrate Storage Maps 的键和值是可迭代的。 由于映射通常用于跟踪无限的数据集（例如账户余额），因此在运行时不小心对其进行迭代可能会导致无法及时生成块。 此外，由于访问映射的元素比访问本地列表的元素需要更多的数据库读取，因此在执行时间方面，映射迭代的成本明显高于列表迭代。 </p>
<blockquote>
<p><strong>关于最佳实践的说明</strong></p>
<p>一般来说，Substrate 专注于根据原则和[最佳实践](<a target="_blank" rel="noopener" href="https://docs.substrate.io/v3/runtime/storage/#best-practices">Storage | Substrate_</a>)进行编程，而不是硬性的对错规则。 此处的信息旨在帮助您了解 Substrate 的所有存储功能以及如何以尊重其设计原则的方式使用它们。 例如，在运行时迭代存储映射既不是对也不是错——然而，就最佳实践而言，避免它会被认为是一种更好的方法。  </p>
</blockquote>
<p>Substrate 的 Iterable Storage Map 接口定义了以下方法： </p>
<ul>
<li><code>iter()</code> - 不按特定顺序枚举映射中的所有元素。 如果您在执行此操作时更改映射，您将得到未定义的结果。 请参阅文档：<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.IterableStorageMap.html#tymethod.iter"><code>IterableStorageMap</code></a>、<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.IterableStorageDoubleMap.html#tymethod.iter"><code>IterableStorageDoubleMap</code></a>和<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.IterableStorageNMap.html#tymethod.iter"><code>IterableStorageNMap</code></a>。 </li>
<li><code>drain()</code> - 从映射中删除所有元素并以不特定顺序遍历它们。 如果您在执行此操作时向映射添加元素，您将获得未定义的结果。 请参阅文档：<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.IterableStorageMap.html#tymethod.iter"><code>IterableStorageMap</code></a>、<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.IterableStorageDoubleMap.html#tymethod.iter"><code>IterableStorageDoubleMap</code></a>和<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.IterableStorageNMap.html#tymethod.iter"><code>IterableStorageNMap</code></a>。 </li>
<li><code>translate()</code> - 使用提供的函数来翻译映射的所有元素，没有特定的顺序。 要从映射中删除元素，请从翻译函数中返回 None。 请参阅文档：<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.IterableStorageMap.html#tymethod.iter"><code>IterableStorageMap</code></a>、<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.IterableStorageDoubleMap.html#tymethod.iter"><code>IterableStorageDoubleMap</code></a>和<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/trait.IterableStorageNMap.html#tymethod.iter"><code>IterableStorageNMap</code></a>。 </li>
</ul>
<h2 id="声明存储项"><a href="#声明存储项" class="headerlink" title="声明存储项"></a>声明存储项</h2><p>在任何基于 FRAME 的托盘中使用[#[pallet::storage]](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/attr.pallet.html#storage-palletstorage-optional">pallet in frame_support - Rust (substrate.io)</a>)创建运行时存储项。 以下是声明四种不同类型的存储项的示例： </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[pallet::storage]</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">SomePrivateValue</span></span>&lt;T&gt; = StorageValue&lt;_, <span class="built_in">u32</span>, ValueQuery&gt;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[pallet::storage]</span></span><br><span class="line"><span class="meta">#[pallet::getter(fn some_primitive_value)]</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="class"><span class="keyword">type</span> <span class="title">SomePrimitiveValue</span></span>&lt;T&gt; = StorageValue&lt;_, <span class="built_in">u32</span>, ValueQuery&gt;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[pallet::storage]</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="class"><span class="keyword">type</span> <span class="title">SomeComplexValue</span></span>&lt;T: Config&gt; = StorageValue&lt;_, T::AccountId, ValueQuery&gt;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[pallet::storage]</span></span><br><span class="line"><span class="meta">#[pallet::getter(fn some_map)]</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="class"><span class="keyword">type</span> <span class="title">SomeMap</span></span>&lt;T: Config&gt; = StorageMap&lt;_, Blake2_128Concat, T::AccountId, <span class="built_in">u32</span>, ValueQuery&gt;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[pallet::storage]</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="class"><span class="keyword">type</span> <span class="title">SomeDoubleMap</span></span>&lt;T: Config&gt; = StorageDoubleMap&lt;_, Blake2_128Concat, <span class="built_in">u32</span>, Blake2_128Concat, T::AccountId, <span class="built_in">u32</span>, ValueQuery&gt;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[pallet::storage]</span></span><br><span class="line"><span class="meta">#[pallet::getter(fn some_nmap)]</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="class"><span class="keyword">type</span> <span class="title">SomeNMap</span></span>&lt;T: Config&gt; = StorageNMap&lt;</span><br><span class="line">    _,</span><br><span class="line">    (</span><br><span class="line">        NMapKey&lt;Blake2_128Concat, <span class="built_in">u32</span>&gt;,</span><br><span class="line">        NMapKey&lt;Blake2_128Concat, T::AccountId)&gt;,</span><br><span class="line">        NMapKey&lt;Twox64Concat, <span class="built_in">u32</span>&gt;,</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">u32</span>,</span><br><span class="line">    ValueQuery,</span><br><span class="line">&gt;;</span><br></pre></td></tr></table></figure>

<p>请注意，映射的存储项需要指定将使用的散列算法。 </p>
<h3 id="QueryKindTrait"><a href="#QueryKindTrait" class="headerlink" title="QueryKindTrait"></a>QueryKindTrait</h3><p>传递给存储项的[<code>QueryKindTrait</code>](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/types/trait.QueryKindTrait.html">QueryKindTrait in frame_support::storage::types - Rust (substrate.io)</a>)的实现决定了当存储中没有值时应该如何处理存储。 使用[<code>OptionQuery</code>](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/types/struct.OptionQuery.html">OptionQuery in frame_support::storage::types - Rust (substrate.io)</a>)，当存储中没有值时，<code>get</code>方法将返回<code>None</code>。 使用 <a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/types/struct.ValueQuery.html"><code>ValueQuery</code></a>，当存储中没有值时，<code>get</code>方法将返回使用<code>OnEmpty</code>泛型配置的值。 对于需要配置特定默认值的情况，建议使用<code>ValueQuery</code>。 </p>
<h3 id="Visibility"><a href="#Visibility" class="headerlink" title="Visibility"></a>Visibility</h3><p>在上面的示例中，除了<code>SomePrivateValue</code>之外的所有存储项都通过<code>pub</code>关键字公开。区块链存储始终从[运行时外部公开可见](<a target="_blank" rel="noopener" href="https://docs.substrate.io/v3/runtime/storage/#accessing-storage-items">Storage | Substrate_</a>)； Substrate 存储项目的可见性仅影响运行时中的其他托盘是否能够访问存储项目。 </p>
<h3 id="Getter方法（Getter-methods）"><a href="#Getter方法（Getter-methods）" class="headerlink" title="Getter方法（Getter methods）"></a>Getter方法（Getter methods）</h3><p><code>#[pallet::getter(..)]</code>宏提供了一个可选的<code>get</code>扩展，可用于为包含该存储项的模块上的存储项实现 getter 方法； 该扩展将所需的 getter 函数名称作为参数。 如果你省略了这个可选的扩展，你仍然可以访问存储项的值，但是你不能通过在模块上实现的 getter 方法来访问； 相反，您将需要使用存储项目的<code>get</code>方法。 </p>
<blockquote>
<p><strong>笔记</strong></p>
<p>可选的<code>getter</code>扩展只影响从 Substrate 代码中访问存储项的方式——您将始终能够[查询运行时的存储](<a target="_blank" rel="noopener" href="https://docs.substrate.io/v3/advanced/storage/#Querying-Storage">Storage | Substrate_</a>)以获取存储项的值。 </p>
</blockquote>
<p>下面是一个为名为<code>SomeValue</code>的存储值实现名为<code>some_value</code>的 getter 方法的示例。 除了<code>SomeValue::get()</code>方法之外，这个托盘现在可以访问<code>Self::some_value()</code>方法： </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[pallet::storage]</span></span><br><span class="line"><span class="meta">#[pallet::getter(fn some_value)]</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="class"><span class="keyword">type</span> <span class="title">SomeValue</span></span> = StorageValue&lt;_, <span class="built_in">u64</span>, ValueQuery&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="默认值（Default-values）"><a href="#默认值（Default-values）" class="headerlink" title="默认值（Default values）"></a>默认值（Default values）</h3><p>Substrate 允许您指定在未设置存储项的值时返回的默认值。 虽然默认值实际上<strong>并不</strong>占用运行时存储，但运行时逻辑在执行过程中会看到这个值。 </p>
<p>这是在存储中指定默认值的示例： </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[pallet::type_value]</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="function"><span class="keyword">fn</span> <span class="title">MyDefault</span></span>&lt;T: Config&gt;() -&gt; T::Balance &#123; <span class="number">3</span>.into() &#125;</span><br><span class="line"><span class="meta">#[pallet::storage]</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="class"><span class="keyword">type</span> <span class="title">MyStorageValue</span></span>&lt;T: Config&gt; =</span><br><span class="line">    StorageValue&lt;Value = T::Balance, QueryKind = ValueQuery, OnEmpty = MyDefault&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>请注意，为了使每个存储字段更加清晰，上面的语法是声明存储项的非缩写版本。 </p>
<h2 id="访问存储项（Accessing-storage-items）"><a href="#访问存储项（Accessing-storage-items）" class="headerlink" title="访问存储项（Accessing storage items）"></a>访问存储项（Accessing storage items）</h2><p>使用 Substrate 构建的区块链公开了可用于查询运行时存储的远程过程调用 (RPC) 服务器。 您可以使用<a href="%5Bpolkadot%7B.js%7D%5D(https://polkadot.js.org/)">Polkadot JS</a>等软件库轻松地从您的代码与 RPC 服务器交互并访问存储项。 Polkadot JS 团队还维护[Polkadot Apps UI](<a target="_blank" rel="noopener" href="https://polkadot.js.org/apps/">Polkadot/Substrate Portal</a>)，这是一个功能齐全的 Web 应用程序，用于与基于 Substrate 的区块链交互，包括查询存储。 </p>
<p>请参阅[高级存储文档](<a target="_blank" rel="noopener" href="https://docs.substrate.io/v3/advanced/storage/">Storage | Substrate_</a>)以了解有关如何使用 RPC 服务器查询 Substrate 键值数据库的更多信息。 </p>
<h3 id="散列算法（Hashing-algorithms）"><a href="#散列算法（Hashing-algorithms）" class="headerlink" title="散列算法（Hashing algorithms）"></a>散列算法（Hashing algorithms）</h3><p>Substrate 中存储映射的一个新特性是它们允许开发人员指定将用于生成映射键的散列算法。 用于封装散列逻辑的 Rust 对象称为“散列器（hasher）”。 广义上讲，Substrate 开发人员可用的哈希器可以用两种方式描述：（1）它们是否是加密的； (2) 它们是否产生透明的输出。</p>
<p>为了完整起见，下面描述了非透明哈希算法的特征，但请记住，对于基于 FRAME 的区块链，不推荐使用任何不产生透明输出的哈希算法。</p>
<h4 id="加密哈希算法（Cryptographic-hashing-algorithms）"><a href="#加密哈希算法（Cryptographic-hashing-algorithms）" class="headerlink" title="加密哈希算法（Cryptographic hashing algorithms）"></a>加密哈希算法（Cryptographic hashing algorithms）</h4><p>密码散列算法使我们能够构建工具，使操纵散列算法的输入以影响其输出变得极其困难。例如，即使输入是数字 1 到 10，加密散列算法也会产生广泛分布的输出。当用户能够影响存储映射的密钥时，使用加密散列算法至关重要。不这样做会创建一个攻击向量，使恶意行为者很容易降低区块链网络的性能。应使用加密哈希算法生成其密钥的映射示例是用于跟踪帐户余额的映射。在这种情况下，使用加密散列算法非常重要，这样攻击者就无法通过向顺序帐号进行许多小额转账来轰炸您的系统。如果没有适当的加密散列算法，这将创建一个不平衡的存储结构，从而影响性能。在本节中阅读有关 Subsrate 中常见哈希的更多信息。</p>
<blockquote>
<p><strong>笔记</strong></p>
<p>加密哈希算法比它们的非加密算法更复杂和资源密集，这就是为什么运行时工程师了解它们的适当用法以充分利用 Substrate 提供的灵活性很重要。</p>
</blockquote>
<h4 id="透明哈希算法（Transparent-hashing-algorithms）"><a href="#透明哈希算法（Transparent-hashing-algorithms）" class="headerlink" title="透明哈希算法（Transparent hashing algorithms）"></a>透明哈希算法（Transparent hashing algorithms）</h4><p>透明散列算法是一种可以轻松发现和验证用于生成给定输出的输入的算法。 在 Substrate 中，散列算法通过将算法的输入连接到其输出而变得透明。 这使得用户检索密钥的原始未散列值并在他们愿意时验证它（通过重新散列）变得微不足道。 Substrate 的创建者已<strong>弃用</strong>在基于 FRAME 的运行时中使用<strong>非透明哈希器</strong>，因此提供此信息主要是为了完整性。 事实上，如果您想访问可迭代的地图功能，则有必要使用透明散列算法。 在[高级存储文档](<a target="_blank" rel="noopener" href="https://docs.substrate.io/v3/advanced/storage/#storage-map-keys">Storage | Substrate_</a>)中详细了解透明散列算法公开的功能。</p>
<h4 id="常见的-Substrate-哈希器（Common-Substrate-hashers）"><a href="#常见的-Substrate-哈希器（Common-Substrate-hashers）" class="headerlink" title="常见的 Substrate 哈希器（Common Substrate hashers）"></a>常见的 Substrate 哈希器（Common Substrate hashers）</h4><p>下表列出了 Substrate 中使用的一些常见哈希，并表示那些是加密的和那些是透明的：</p>
<table>
<thead>
<tr>
<th>散列器</th>
<th>加密算法</th>
<th>透明</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/struct.Blake2_128Concat.html">Blake2 128 Concat</a></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/struct.Twox64Concat.html">TwoX 64 Concat</a></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/struct.Identity.html">Identity</a></td>
<td></td>
<td>X</td>
</tr>
</tbody></table>
<p>身份散列器封装了一个散列算法，其输出等于其输入（身份函数）。 仅当起始密钥已经是加密哈希时才应使用这种类型的哈希。</p>
<h3 id="创世配置（Genesis-configuration）"><a href="#创世配置（Genesis-configuration）" class="headerlink" title="创世配置（Genesis configuration）"></a>创世配置（Genesis configuration）</h3><p>Substrate 的运行时存储 API 包括初始化区块链创世块中的存储项的功能。 创世存储配置 API 公开了许多初始化存储的机制，所有这些机制都在<code>#[pallet::genesis_config]</code>中有入口点。 GenesisConfig 数据类型在属性<code>#[pallet::genesis_config]</code>下定义，属性<code>#[pallet::genesis_build]</code>用于构建创世配置。</p>
<p>为了使用托盘的创世配置功能，您必须在将托盘添加到运行时时包含<code>Config</code>元素。 通知运行时的托盘的所有<code>GenesisConfig</code>类型将聚合为该运行时的单个<code>GenesisConfig</code>类型，该类型实现了 [<code>BuildStorage</code> trait](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/sp_runtime/trait.BuildStorage.html">BuildStorage in sp_runtime - Rust (substrate.io)</a>)。 例如，在[<code>node_template_runtime::GenesisConfig</code>](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/node_template_runtime/struct.GenesisConfig.html">GenesisConfig in node_template_runtime - Rust (substrate.io)</a>)结构中，此类型的每个属性对应于运行时托盘中具有<code>Config</code>元素的<code>GenesisConfig</code>。 最终，运行时的<code>GenesisConfig</code>通过 [<code>ChainSpec trait</code>](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/sc_chain_spec/trait.ChainSpec.html">ChainSpec in sc_chain_spec - Rust (substrate.io)</a>)暴露出来。</p>
<p>有关使用 Substrate 创世存储配置功能的完整具体示例，请参阅<a target="_blank" rel="noopener" href="https://github.com/paritytech/substrate/blob/master/bin/node/cli/src/chain_spec.rs">Substrate 代码库随附的链规范</a>中 Society 托盘存储的创世配置。 继续阅读以获取有关这些功能的更详细说明。</p>
<h4 id="genesis-config"><a href="#genesis-config" class="headerlink" title="genesis_config"></a><code>genesis_config</code></h4><p>[<code>#[pallet::genesis_config]</code>](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/attr.pallet.html#genesis-config-palletgenesis_config-optional">pallet in frame_support - Rust (substrate.io)</a>)宏提供了一个扩展，它将向托盘的<code>GenesisConfig</code>数据类型添加一个属性。 该属性的值将用作您链的创世块中存储项的初始值。 <code>config</code>扩展采用一个参数，该参数将确定<code>GenesisConfig</code>数据类型的属性名称——如果提供了<code>get</code>扩展，则此参数是可选的。</p>
<p>这是一个示例，它演示了使用名为<code>MyVal</code>的存储值的<code>config</code>扩展来为存储值的托盘在<code>GenesisConfig</code>数据类型上创建一个名为<code>init_val</code>的属性。 然后在一个示例中使用此属性，该示例演示使用<code>GenesisConfig</code>类型在您的链的创世块中设置存储值的初始值。</p>
<p>在<code>my_pallet/src/lib.rs</code>中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[pallet::genesis_config]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">GenesisConfig</span></span>&lt;T: Config&gt; &#123;</span><br><span class="line">        <span class="keyword">pub</span> init_val: <span class="built_in">u64</span>,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>chain_spec.rs</code>中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GenesisConfig &#123;</span><br><span class="line">    my_pallet: MyPalletConfig &#123;</span><br><span class="line">        init_val: <span class="number">221u64</span> + SOME_CONSTANT_VALUE,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="genesis-build"><a href="#genesis-build" class="headerlink" title="genesis_build"></a><code>genesis_build</code></h4><p>[<code>#[pallet::genesis_build]</code>](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/attr.pallet.html#genesis-build-palletgenesis_build-optional">pallet in frame_support - Rust (substrate.io)</a>) 属性允许您定义<code>genesis_configuration</code>如何在托盘本身内构建（这使您可以访问托盘的私有功能）。</p>
<p>这是一个示例，演示使用<code>#[pallet::genesis_config]</code>和<code>#[pallet::genesis_build]</code>设置存储项的初始值。 在这种情况下，该示例涉及两个存储项：一个表示成员帐户 ID 列表，另一个指定列表中的特殊成员（主要成员）。</p>
<p>在<code>my_pallet/src/lib.rs</code>中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[pallet::genesis_config]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GenesisConfig</span></span> &#123;</span><br><span class="line">    members: <span class="built_in">Vec</span>&lt;T::AccountId&gt;,</span><br><span class="line">    prime: T::AccountId,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[pallet::genesis_build]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; GenesisBuild&lt;T&gt; <span class="keyword">for</span> GenesisConfig &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">build</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        Pallet::&lt;T&gt;::initialize_members(&amp;<span class="keyword">self</span>.members);</span><br><span class="line">        SomeStorageItem::&lt;T&gt;::put(<span class="keyword">self</span>.prime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>chain_spec.rs</code>中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GenesisConfig &#123;</span><br><span class="line">    my_pallet: MyPalletConfig &#123;</span><br><span class="line">        members: LIST_OF_IDS,</span><br><span class="line">        prime: ID,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以使用<code>genesis_build</code>定义未绑定到特定存储项的<code>GenesisConfig</code>属性。 如果您希望在您的托盘中调用一个设置多个存储项目的私有帮助函数，或者调用在您的托盘中包含的其他一些托盘中定义的函数，这可能是可取的。 例如，使用名为<code>intitialize_members</code>的虚构私有函数，它看起来像：</p>
<p>在<code>my_pallet/src/lib.rs</code>中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[pallet::genesis_config]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GenesisConfig</span></span> &#123;</span><br><span class="line">    members: <span class="built_in">Vec</span>&lt;T::AccountId&gt;,</span><br><span class="line">    prime: T::AccountId,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[pallet::genesis_build]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Config&gt; GenesisBuild&lt;T&gt; <span class="keyword">for</span> GenesisConfig &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">build</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        Pallet::&lt;T&gt;::initialize_members(&amp;config.members);</span><br><span class="line">        SomeStorageItem::&lt;T&gt;::put(<span class="keyword">self</span>.prime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>chain_spec.rs</code>中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GenesisConfig &#123;</span><br><span class="line">    my_pallet: MyPalletConfig &#123;</span><br><span class="line">        members: LIST_OF_IDS,</span><br><span class="line">        prime: ID,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最佳实践（Best-practices）"><a href="#最佳实践（Best-practices）" class="headerlink" title="最佳实践（Best practices）"></a>最佳实践（Best practices）</h3><p>Substrate 的目标是提供一个灵活的框架，让人们可以构建适合他们需求的区块链——Substrate 的创建者往往不会以“对”或“错”的方式思考。 尽管如此，Substrate 代码库遵循了许多最佳实践，以促进创建安全、高性能和可长期维护的区块链网络。 以下部分概述了使用 Substrate 存储的最佳实践，并描述了激励他们的重要首要原则。</p>
<h4 id="存储什么（What-to-store）"><a href="#存储什么（What-to-store）" class="headerlink" title="存储什么（What to store）"></a>存储什么（What to store）</h4><p>请记住，区块链运行时存储的基本原则是尽量减少其使用。只有共识关键数据应该存储在您的运行时中。如果可能，请使用散列等技术来减少必须存储的数据量。例如，许多 Substrate 的治理功能（例如 Democracy 托盘的[<code>提议</code>可调度](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/pallet_democracy/pallet/enum.Call.html#variant.propose">Call in pallet_democracy::pallet - Rust (substrate.io)</a>)）允许网络参与者对始终有大小限制的可调度调用的哈希进行投票，而调用本身的长度可能是无限的。在运行时升级的情况下尤其如此，其中可调度调用将整个运行时 Wasm blob 作为其参数。因为这些治理机制是在链上实现的，所以就给定提案的状态达成共识所需的所有信息也必须存储在链上——这包括正在投票的内容。然而，通过将链上提案绑定到其哈希值，Substrate 的治理机制允许以将与提案相关的所有数据延迟到其被批准后的方式完成此操作。这意味着存储不会浪费在失败的提案上。一旦提案通过，有人可以发起实际的可调度调用（包括其所有参数），该调用将被散列并与提案中的散列进行比较。使用散列来最小化存储在链上的数据的另一种常见模式是将与<a target="_blank" rel="noopener" href="https://docs.ipfs.io/">IPFS</a>中的对象关联的原图像存储；这意味着只有 IPFS 位置（大小有界的哈希）需要存储在链上。</p>
<p>哈希只是可用于控制运行时存储大小的一种机制。 另一种机制的一个例子是边界。</p>
<h4 id="先验证，最后写（Verify-first-write-last）"><a href="#先验证，最后写（Verify-first-write-last）" class="headerlink" title="先验证，最后写（Verify first, write last）"></a>先验证，最后写（Verify first, write last）</h4><p>Substrate 不会在外部调度之前缓存状态。 相反，它在调用更改时直接应用更改。 如果外部失败，任何状态更改都将持续存在。 因此，在确定满足所有先决条件之前不要进行任何存储突变，这一点很重要。 一般而言，可能导致存储变异的代码块应按如下结构构成：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// all checks and throwing code go here</span></span><br><span class="line">  <span class="comment">//所有检查和抛出代码都在这里</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ** no throwing code below this line **</span></span><br><span class="line">  <span class="comment">// ** 此行下方没有抛出代码 **</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// all event emissions &amp; storage writes go here</span></span><br><span class="line">  <span class="comment">// 所有事件发射和存储写入都在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要使用运行时存储来存储逻辑原子操作的上下文中的中间或临时数据或操作失败时不需要的数据。 这并不意味着不应使用运行时存储来跟踪需要多个原子操作的正在进行的操作的状态，例如[来自实用程序托盘的多重签名功能](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/pallet_utility/pallet/enum.Call.html#variant.as_multi">Call in pallet_utility::pallet - Rust (substrate.io)</a>)。 在这种情况下，运行时存储用于跟踪可调度调用上的签名者，即使给定调用可能永远不会收到足够的签名来实际调用。 在这种情况下，每个签名都被认为是正在进行的多重签名操作中的一个原子事件； 在满足与该签名相关的所有先决条件之前，不会存储记录单个签名所需的数据。</p>
<h4 id="创建边界（Create-bounds）"><a href="#创建边界（Create-bounds）" class="headerlink" title="创建边界（Create bounds）"></a>创建边界（Create bounds）</h4><p>创建存储项大小的界限是控制运行时存储使用的一种非常有效的方法，并且在整个 Substrate 代码库中重复使用。 一般来说，任何大小由用户操作决定的存储项目都应该有一个界限。 上面描述的[来自实用程序托盘的多重签名功能](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/pallet_utility/trait.Config.html#associatedtype.MaxSignatories">Page not found · GitHub Pages (substrate.io)</a>)就是一个这样的例子。 在这种情况下，与多签名操作相关联的签名者列表由多签名参与者提供。 因为这个签名列表是就多重签名操作的状态达成共识所必需的，所以它必须存储在运行时中。 但是，为了让运行时开发人员能够控制这些列表可能占用多少存储空间，实用工具托盘要求用户在此数字上配置一个界限，该界限将作为先决条件包含在内，然后再将任何内容写入存储。</p>
<h2 id="下一步（Next-steps）"><a href="#下一步（Next-steps）" class="headerlink" title="下一步（Next steps）"></a>下一步（Next steps）</h2><h3 id="深入学习（Learn-more）"><a href="#深入学习（Learn-more）" class="headerlink" title="深入学习（Learn more）"></a>深入学习（Learn more）</h3><p>阅读[高级存储文档](<a target="_blank" rel="noopener" href="https://docs.substrate.io/v3/advanced/storage/">Storage | Substrate_</a>)</p>
<h3 id="示例（Examples）"><a href="#示例（Examples）" class="headerlink" title="示例（Examples）"></a>示例（Examples）</h3><p>查看一些涵盖各种存储主题的指南：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.substrate.io/how-to-guides/v3/basics/mint-token/">Using a Storage Map</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.substrate.io/how-to-guides/v3/pallet-design/storage-value/">Structs in storage</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.substrate.io/how-to-guides/v3/storage-migrations/basics/">Storage migration</a></li>
</ul>
<h3 id="参考（References）"><a href="#参考（References）" class="headerlink" title="参考（References）"></a>参考（References）</h3><ul>
<li>有关可用存储声明的更多详细信息，请访问[#[frame_support::pallet] 宏](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/attr.pallet.html#storage-palletstorage-optional">pallet in frame_support - Rust (substrate.io)</a>)的参考文档。</li>
<li>访问[StorageValue](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/types/struct.StorageValue.html">StorageValue in frame_support::storage::types - Rust (substrate.io)</a>)、[StorageMap](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/types/struct.StorageMap.html">StorageMap in frame_support::storage::types - Rust (substrate.io)</a>)、[StorageDoubleMap](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/types/struct.StorageDoubleMap.html">StorageDoubleMap in frame_support::storage::types - Rust (substrate.io)</a>)和[StorageNMap](<a target="_blank" rel="noopener" href="https://docs.substrate.io/rustdocs/latest/frame_support/storage/types/struct.StorageNMap.html">StorageNMap in frame_support::storage::types - Rust (substrate.io)</a>)的参考文档，了解有关其 API 的更多信息。</li>
</ul>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">天了噜Rex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/01/27/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%203.4%20Runtime%20Development%20-%20Storage/">http://example.com/2022/01/27/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%203.4%20Runtime%20Development%20-%20Storage/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a></div><div class="post_share"><div class="social-share" data-image="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/17/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%203.5%20Runtime%20Development%20-%20Origins/"><img class="prev-cover" src="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">《Substrate Docs》翻译 3.5 Runtime Development - Origins</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/25/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%203.3%20Runtime%20Development%20-%20Metadata/"><img class="next-cover" src="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">《Substrate Docs》翻译 3.3 Runtime Development - Metadata</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%201.1%20Getting%20Started%20-%20Welcome/" title="《Substrate Docs》翻译 1.1 Getting Started - Welcome"><img class="cover" src="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-03</div><div class="title">《Substrate Docs》翻译 1.1 Getting Started - Welcome</div></div></a></div><div><a href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%201.2%20Getting%20Started%20-%20Architecture/" title="《Substrate Docs》翻译 1.2 Getting Started - Architecture"><img class="cover" src="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-03</div><div class="title">《Substrate Docs》翻译 1.2 Getting Started - Architecture</div></div></a></div><div><a href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%201.3%20Getting%20Started%20-%20Installation/" title="《Substrate Docs》翻译 1.3 Getting Started - Installation"><img class="cover" src="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-03</div><div class="title">《Substrate Docs》翻译 1.3 Getting Started - Installation</div></div></a></div><div><a href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%201.5%20Getting%20Started%20-%20Glossary/" title="《Substrate Docs》翻译 1.5 Getting Started - Glossary"><img class="cover" src="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-03</div><div class="title">《Substrate Docs》翻译 1.5 Getting Started - Glossary</div></div></a></div><div><a href="/2022/01/09/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%202.1%20Key%20Concepts%20-%20Runtime/" title="《Substrate Docs》翻译 2.1 Key Concepts - Runtime"><img class="cover" src="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-09</div><div class="title">《Substrate Docs》翻译 2.1 Key Concepts - Runtime</div></div></a></div><div><a href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%201.4%20Getting%20Started%20-%20Getting%20Started%20on%20Windows/" title="《Substrate Docs》翻译 1.4 Getting Started - Getting Started on Windows"><img class="cover" src="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-03</div><div class="title">《Substrate Docs》翻译 1.4 Getting Started - Getting Started on Windows</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">天了噜Rex</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Phantasm-of-Observer"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">某王姓男子的杂物堆（个人博客），欢迎各位来访orz！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%EF%BC%88Storage%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">存储（Storage）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E9%A1%B9%EF%BC%88Storage-items%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">存储项（Storage items）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%80%BC%EF%BC%88Storage-value%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">存储值（Storage value）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84%EF%BC%88Storage-map%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">存储映射（Storage map）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84%EF%BC%88Double-storage-map%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">双存储映射（Double storage map）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84%EF%BC%88N-storage-map%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">N存储映射（N storage map）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84%EF%BC%88Iterating-over-Storage-Maps%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">迭代存储映射（Iterating over Storage Maps）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%AD%98%E5%82%A8%E9%A1%B9"><span class="toc-number">1.2.</span> <span class="toc-text">声明存储项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QueryKindTrait"><span class="toc-number">1.2.1.</span> <span class="toc-text">QueryKindTrait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Visibility"><span class="toc-number">1.2.2.</span> <span class="toc-text">Visibility</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Getter%E6%96%B9%E6%B3%95%EF%BC%88Getter-methods%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">Getter方法（Getter methods）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%88Default-values%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">默认值（Default values）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8%E9%A1%B9%EF%BC%88Accessing-storage-items%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">访问存储项（Accessing storage items）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95%EF%BC%88Hashing-algorithms%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">散列算法（Hashing algorithms）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%88Cryptographic-hashing-algorithms%EF%BC%89"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">加密哈希算法（Cryptographic hashing algorithms）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%88Transparent-hashing-algorithms%EF%BC%89"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">透明哈希算法（Transparent hashing algorithms）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-Substrate-%E5%93%88%E5%B8%8C%E5%99%A8%EF%BC%88Common-Substrate-hashers%EF%BC%89"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">常见的 Substrate 哈希器（Common Substrate hashers）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E4%B8%96%E9%85%8D%E7%BD%AE%EF%BC%88Genesis-configuration%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">创世配置（Genesis configuration）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#genesis-config"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">genesis_config</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#genesis-build"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">genesis_build</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%88Best-practices%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">最佳实践（Best practices）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BB%80%E4%B9%88%EF%BC%88What-to-store%EF%BC%89"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">存储什么（What to store）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E9%AA%8C%E8%AF%81%EF%BC%8C%E6%9C%80%E5%90%8E%E5%86%99%EF%BC%88Verify-first-write-last%EF%BC%89"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">先验证，最后写（Verify first, write last）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BE%B9%E7%95%8C%EF%BC%88Create-bounds%EF%BC%89"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">创建边界（Create bounds）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E6%AD%A5%EF%BC%88Next-steps%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">下一步（Next steps）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%EF%BC%88Learn-more%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">深入学习（Learn more）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%88Examples%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">示例（Examples）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%EF%BC%88References%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">参考（References）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/05/%E3%80%8ASubstrate%20How-to%20Guides%E3%80%8B%E7%BF%BB%E8%AF%91%202.3%20Pallet%20Design%20-%20Implementing%20Randomness/" title="《Substrate How-to Guides》翻译 2.3 Pallet Design - Implementing Randomness"><img src="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Substrate How-to Guides》翻译 2.3 Pallet Design - Implementing Randomness"/></a><div class="content"><a class="title" href="/2022/03/05/%E3%80%8ASubstrate%20How-to%20Guides%E3%80%8B%E7%BF%BB%E8%AF%91%202.3%20Pallet%20Design%20-%20Implementing%20Randomness/" title="《Substrate How-to Guides》翻译 2.3 Pallet Design - Implementing Randomness">《Substrate How-to Guides》翻译 2.3 Pallet Design - Implementing Randomness</a><time datetime="2022-03-05T13:41:53.000Z" title="Created 2022-03-05 21:41:53">2022-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/03/%E3%80%8AComputer%20Networking%20A%20Top-Down%20Approach%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Chapter%201%20Computer%20Networks%20and%20the%20Internet/" title="《Computer Networking A Top-Down Approach》学习笔记 Chapter 1 Computer Networks and the Internet"><img src="https://img-blog.csdnimg.cn/acd635d2772b4d328ebed940a9e1b508.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Computer Networking A Top-Down Approach》学习笔记 Chapter 1 Computer Networks and the Internet"/></a><div class="content"><a class="title" href="/2022/03/03/%E3%80%8AComputer%20Networking%20A%20Top-Down%20Approach%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Chapter%201%20Computer%20Networks%20and%20the%20Internet/" title="《Computer Networking A Top-Down Approach》学习笔记 Chapter 1 Computer Networks and the Internet">《Computer Networking A Top-Down Approach》学习笔记 Chapter 1 Computer Networks and the Internet</a><time datetime="2022-03-03T14:20:30.000Z" title="Created 2022-03-03 22:20:30">2022-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/17/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%203.5%20Runtime%20Development%20-%20Origins/" title="《Substrate Docs》翻译 3.5 Runtime Development - Origins"><img src="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Substrate Docs》翻译 3.5 Runtime Development - Origins"/></a><div class="content"><a class="title" href="/2022/02/17/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%203.5%20Runtime%20Development%20-%20Origins/" title="《Substrate Docs》翻译 3.5 Runtime Development - Origins">《Substrate Docs》翻译 3.5 Runtime Development - Origins</a><time datetime="2022-02-16T16:37:20.000Z" title="Created 2022-02-17 00:37:20">2022-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/27/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%203.4%20Runtime%20Development%20-%20Storage/" title="《Substrate Docs》翻译 3.4 Runtime Development - Storage"><img src="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Substrate Docs》翻译 3.4 Runtime Development - Storage"/></a><div class="content"><a class="title" href="/2022/01/27/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%203.4%20Runtime%20Development%20-%20Storage/" title="《Substrate Docs》翻译 3.4 Runtime Development - Storage">《Substrate Docs》翻译 3.4 Runtime Development - Storage</a><time datetime="2022-01-26T17:43:01.000Z" title="Created 2022-01-27 01:43:01">2022-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/25/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%203.3%20Runtime%20Development%20-%20Metadata/" title="《Substrate Docs》翻译 3.3 Runtime Development - Metadata"><img src="https://img-blog.csdnimg.cn/d0fdf90195a647c2a285c48e3ae54f0c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Substrate Docs》翻译 3.3 Runtime Development - Metadata"/></a><div class="content"><a class="title" href="/2022/01/25/%E3%80%8ASubstrate%20Docs%E3%80%8B%E7%BF%BB%E8%AF%91%203.3%20Runtime%20Development%20-%20Metadata/" title="《Substrate Docs》翻译 3.3 Runtime Development - Metadata">《Substrate Docs》翻译 3.3 Runtime Development - Metadata</a><time datetime="2022-01-25T07:26:01.000Z" title="Created 2022-01-25 15:26:01">2022-01-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 天了噜Rex</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>