<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《C Primer Plus》学习笔记_第三章 数据和C | 天了噜Rex的杂物堆</title><meta name="author" content="天了噜Rex"><meta name="copyright" content="天了噜Rex"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第3章 数据和C关键字：int 、short、long、unsigned、char、float、double、_Bool、_Complex、_Imaginary 运算符：sizeof() 函数：scanf()  示例程序12345678910111213141516171819&#x2F;* platinum.c -- your weight in platinum *&#x2F;#include &lt;stdio">
<meta property="og:type" content="article">
<meta property="og:title" content="《C Primer Plus》学习笔记_第三章 数据和C">
<meta property="og:url" content="http://example.com/2021/11/17/%E3%80%8AC%20Primer%20Plus%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%92%8CC/index.html">
<meta property="og:site_name" content="天了噜Rex的杂物堆">
<meta property="og:description" content="第3章 数据和C关键字：int 、short、long、unsigned、char、float、double、_Bool、_Complex、_Imaginary 运算符：sizeof() 函数：scanf()  示例程序12345678910111213141516171819&#x2F;* platinum.c -- your weight in platinum *&#x2F;#include &lt;stdio">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-11-17T12:07:01.000Z">
<meta property="article:modified_time" content="2021-11-18T07:57:06.165Z">
<meta property="article:author" content="天了噜Rex">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/11/17/%E3%80%8AC%20Primer%20Plus%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%92%8CC/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《C Primer Plus》学习笔记_第三章 数据和C',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-18 15:57:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">29</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">天了噜Rex的杂物堆</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《C Primer Plus》学习笔记_第三章 数据和C</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-11-17T12:07:01.000Z" title="Created 2021-11-17 20:07:01">2021-11-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-11-18T07:57:06.165Z" title="Updated 2021-11-18 15:57:06">2021-11-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《C Primer Plus》学习笔记_第三章 数据和C"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第3章-数据和C"><a href="#第3章-数据和C" class="headerlink" title="第3章 数据和C"></a>第3章 数据和C</h1><p><strong>关键字</strong>：int 、short、long、unsigned、char、float、double、_Bool、<br>_Complex、_Imaginary</p>
<p><strong>运算符</strong>：sizeof()</p>
<p><strong>函数</strong>：scanf()</p>
<hr>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* platinum.c -- your weight in platinum */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> weight; <span class="comment">/* 你的体重 */</span></span><br><span class="line">	<span class="keyword">float</span> value; <span class="comment">/* 相等重量的白金价值 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Are you worth your weight in platinum?\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s check it out.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please enter your weight in pounds: &quot;</span>);</span><br><span class="line">	<span class="comment">/* 获取用户的输入 */</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;weight);</span><br><span class="line">	<span class="comment">/* 假设白金的价格是每盎司$1700 */</span></span><br><span class="line">	<span class="comment">/* 14.5833用于把英镑常衡盎司转换为金衡盎司[1]*/</span></span><br><span class="line">	value = <span class="number">1700.0</span> * weight * <span class="number">14.5833</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Your weight in platinum is worth $%.2f.\n&quot;</span>, value);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;You are easily worth that! If platinum prices drop,\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;eat more to maintain your value.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>提示错误与警告</strong>：<br>如果输入程序时打错（如，漏了一个分号），编译器会报告语法错误消息。然而，即使输入正确无误，编译器也可能给出一些警告，如“警告：从double类型转换成float类型可能会丢失数据”。错误消息表明程序中有错，不能进行编译。而警告则表明，尽管编写的代码有效，但可能不是程序员想要的。警告并不终止编译。</p>
<h3 id="程序中的新元素"><a href="#程序中的新元素" class="headerlink" title="程序中的新元素"></a>程序中的新元素</h3><p>本例使用了浮点数类型（float）的变量，以便处理更大范围的数据。float 类型可以储存带小数的数字。</p>
<p>为了打印新类型的变量，在printf()中使用%f来处理浮点值。%.2f中的.2用于精确控制输出，指定输出的浮点数只显示小数点后面两位。</p>
<p>scanf()函数用于读取键盘的输入。%f说明scanf()要读取用户从键盘输入的浮点数，&amp;weight告诉 scanf()把输入的值赋给名为 weight 的变量。scanf()函数使用&amp;符号表明找到 weight变量的地点。</p>
<p>本程序最突出的新特点是它的交互性。计算机向用户询问信息，然后用户输入数字。与非交互式程序相比，交互式程序用起来更有趣。更重要的是，交互式使得程序更加灵活。</p>
<p>scanf()和printf()函数用于实现这种交互。scanf()函数读取用户从键盘输入的数据，并把数据传递给程序；printf()函数读取程序中的数据，并把数据显示在屏幕上。把两个函数结合起来，就可以建立人机双向通信。<br><img src="https://img-blog.csdnimg.cn/20201109195104920.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="程序中的scanf()和printf()函数"></p>
<hr>
<h2 id="变量与常量数据"><a href="#变量与常量数据" class="headerlink" title="变量与常量数据"></a>变量与常量数据</h2><p>有些数据类型在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化，这些称为常量（constant）。其他数据类型在程序运行期间可能会改变或被赋值，这些称为变量（variable）。</p>
<hr>
<h2 id="数据：数据类型关键字"><a href="#数据：数据类型关键字" class="headerlink" title="数据：数据类型关键字"></a>数据：数据类型关键字</h2><p>C通过识别一些基本的数据类型来区分和使用这些不同的数据类型。如果数据是常量，编译器一般通过用户书写的形式来识别类型（如，42是整数，42.100是浮点数）。但是，对变量而言，要在声明时指定其类型。<br><img src="https://img-blog.csdnimg.cn/20201109195436919.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="C语言的数据类型关键字"><br>在C语言中，用<strong>int</strong>关键字来表示基本的整数类型。后3个关键字（<strong>long</strong>、<strong>short</strong>和<strong>unsigned</strong>）和C90新增的<strong>signed</strong>用于提供基本整数类型的变式，例如unsigned short int和long long int。<strong>char</strong>关键字用于指定字母和其他字符（如，#、$、%和<em>）。另外，char类型也可以表示较小的整数。<strong>float</strong>、<strong>double</strong>和long double表示带小数点的数。*</em>_Bool<strong>类型表示布尔值（true或false），</strong>_complex**和 <strong>_Imaginary</strong>分别表示复数和虚数。</p>
<p>通过这些关键字创建的类型，按计算机的储存方式可分为两大基本类型：<strong>整数类型</strong>和<strong>浮点数类型</strong>。</p>
<blockquote>
<p><strong>拓展</strong>：<br><em>位、字节和字</em> 是描述计算机数据单元或存储单元的术语。这里主要指存储单元。</p>
<p>最小的存储单元是<em>位</em>（bit），可以储存0或1（或者说，位用于设置“开”或“关”）。虽然1位储存的信息有限，但是计算机中位的数量十分庞大。位是计算机内存的基本构建块。</p>
<p><em>字节</em>（byte）是常用的计算机存储单位。对于几乎所有的机器，1字节均为8位。这是字节的标准定义，至少在衡量存储单位时是这样（但是，C语言对此有不同的定义，请参阅本章3.4.3节）。既然1位可以表示0或1，那么8位字节就有256（2的8次方）种可能的0、1的组合。通过二进制编码（仅用0和1便可表示数字），便可表示0～255的整数或一组字符。</p>
<p><em>字</em>（word）是设计计算机时给定的自然存储单位。对于8位的微型计算<br>机（如，最初的苹果机）， 1个字长只有8位。从那以后，个人计算机字长<br>增至16位、32位，直到目前的64位。计算机的字长越大，其数据转移越快，<br>允许的内存访问也更多。</p>
</blockquote>
<h3 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h3><p>对我们而言，整数和浮点数的区别是它们的书写方式不同。对计算机而言，它们的区别是储存方式不同。</p>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>在C语言中，整数是没有小数部分的数。例如，2、−23和2456都是整数。而3.14、0.22和2.000都不是整数。计算机以二进制数字储存整数，例如，整数7以二进制写是111。因此，要在8位字节中储存该数字，需要把前5位都设置成0，后3位设置成1。<br><img src="https://img-blog.csdnimg.cn/20201109200441772.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="使用二进制编码储存整数7"></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>2.75、3.16E7、7.00 和 2e-8 都是浮点数。注意，在一个值后面加上一个小数点，该值就成为一个浮点值。所以，7是整数，7.00是浮点数。</p>
<p>3.16E7 表示3.16×10^7^（3.16 乘以10 的7次方）。其中， 10^7^=10000000，7被称为10的指数。</p>
<p>浮点数和整数的储存方案不同。计算机把浮点数分成小数部分和指数部分来表示，而且分开储存这两部分。因此，虽然7.00和7在数值上相同，但是它们的储存方式不同。在十进制下，可以把7.0写成0.7E1。<br><img src="https://img-blog.csdnimg.cn/20201109201027477.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="以浮点格式（十进制）储存π的值"><br><strong>整型与浮点型的实际区别</strong>：<br>1.整数没有小数部分，浮点数有小数部分。<br>2.浮点数可以表示的范围比整数大。<br>3.对于一些算术运算（如，两个很大的数相减），浮点数损失的精度更多。<br>4.因为在任何区间内（如，1.0 到 2.0 之间)都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值。浮点数通常只是实际值的近似值。例如，7.0可能被储存为浮点值6.99999。<br>5.过去，浮点运算比整数运算慢。不过，现在许多CPU都包含浮点处理器，缩小了速度上的差距。</p>
<hr>
<h2 id="C语言基本数据类型"><a href="#C语言基本数据类型" class="headerlink" title="C语言基本数据类型"></a>C语言基本数据类型</h2><h3 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h3><p>C语言中的整数类型可表示不同的取值范围和正负值。一般情况使用int类型即可，但是为满足特定任务和机器的要求，还可以选择其他类型。<br>int类型是有符号整型，即int类型的值必须是整数，可以是正整数、负整数或零。其取值范围依计算机系统而异。一般而言，储存一个int要占用一个机器字长。ISO C规定int的取值范围最小为-32768～32767。一般而言，系统用一个特殊位的值表示有符号整数的正负号。</p>
<h5 id="声明int变量"><a href="#声明int变量" class="headerlink" title="声明int变量"></a>声明int变量</h5><p>先写上int，然后写变量名，最后加上一个分号。要声明多个变量，可以单独声明每个变量，也可在int后面列出多个变量名，变量名之间用逗号分隔。两种方法的效果相同，都为4个int大小的变量赋予名称并分配内存空间。</p>
<p>程序中获得值的途径有三种：一是赋值，二是通过函数（如，scanf()）获得值，三是初始化变量。</p>
<h5 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h5><p>初始化（initialize）变量就是为变量赋一个初始值。在C语言中，初始化可以直接在声明中完成。只需在变量名后面加上赋值运算符（=）和待赋给变量的值即可。</p>
<p>声明为变量创建和标记存储空间，并为其指定初始值。<br><img src="https://img-blog.csdnimg.cn/20201109202027143.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="定义并初始化变量"><br>==建议：最好不要把初始化的变量和未初始化的变量放在同一条声明中。==</p>
<h5 id="int类型常量"><a href="#int类型常量" class="headerlink" title="int类型常量"></a>int类型常量</h5><p>C语言把不含小数点和指数的数作为整数。C语言把大多数整型常量视为int类型，但是非常大的整数除外。</p>
<h5 id="打印int值"><a href="#打印int值" class="headerlink" title="打印int值"></a>打印int值</h5><p>可以使用printf()函数打印int类型的值。</p>
<p>%d指明了在一行中打印整数的位置。%d称为转换说明，它指定了printf()应使用什么格式来显示一个值。格式化字符串中的每个%d都与待打印变量列表中相应的int值匹配。这个值可以是int类型的变量、int类型的常量或其他任何值为int类型<br>的表达式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* print1.c - 演示printf()的一些特性 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ten = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> two = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Doing it right: &quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d minus %d is %d\n&quot;</span>, ten, <span class="number">2</span>, ten - two);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Doing it wrong: &quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d minus %d is %d\n&quot;</span>, ten); <span class="comment">// 遗漏2个参数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行该程序，输出如下：<br>Doing it right: 10 minus 2 is 8<br>Doing it wrong: 10 minus 16 is 1650287143</p>
<p>在第一行输出中，第1个%d对应int类型变量ten；第2个%d对应int类型常量2；第3个%d对应int类型表达式ten - two的值。在第二行输出中，第1个%d对应ten的值，但是由于没有给后两个%d提供任何值，所以打印出的值是内存中的任意值（读在运行该程序时显示的这两个数值可能会与输出示例中的数值不同，因为内存中储存的数据不同，而且编译器管理内存的位置也不同）。</p>
<p>记住，使用printf()函数时，要确保转换说明的数量与待打印值的数量相等。</p>
<h5 id="八进制和十六进制"><a href="#八进制和十六进制" class="headerlink" title="八进制和十六进制"></a>八进制和十六进制</h5><p>通常，C语言都假定整型常量是十进制数。</p>
<p>然而八进制与十六进制更常被程序员们使用。因为8和16都是2的幂，而10却不是。八进制和十六进制记数系统在表达与计算机相关的值时很方便。十进制数65536经常出现在16位机中，用十六进制表示正好是10000。另外，十六进制数的每一位的数恰好由4位二进制数表示。</p>
<p>在C语言中，用特定的前缀表示使用哪种进制。0前缀表示八进制。0x或0X前缀表示十六进制值。</p>
<p>使用不同的进制数是为了方便，不会影响数被储存的方式。因为计算机内部都以二进制进行编码。</p>
<h5 id="显示八进制和十六进制"><a href="#显示八进制和十六进制" class="headerlink" title="显示八进制和十六进制"></a>显示八进制和十六进制</h5><p>在C程序中，既可以使用和显示不同进制的数。不同的进制要使用不同的转换说明。以十进制显示数字，使用%d；以八进制显示数字，使用%o；以十六进制显示数字，使用%x。另外，要显示各进制数的前缀0、0x和0X，必须分别使用%#o、%#x、%#X。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bases.c--以十进制、八进制、十六进制打印十进制数100 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;dec = %d; octal = %o; hex = %x\n&quot;</span>, x, x, x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;dec = %d; octal = %#o; hex = %#x\n&quot;</span>, x, x, x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行该程序，输出如下：<br>dec = 100; octal = 144; hex = 64<br>dec = 100; octal = 0144; hex = 0x64</p>
<h3 id="其他整数类型"><a href="#其他整数类型" class="headerlink" title="其他整数类型"></a>其他整数类型</h3><p>C语言提供3个附属关键字修饰基本整数类型：short、long和unsigned。应记住以下几点。</p>
<p>short int类型（或者简写为short）占用的存储空间可能比int类型少，常用于较小数值的场合以节省空间。与int类似，short是有符号类型。</p>
<p>long int或long占用的存储空间可能比int多，适用于较大数值的场合。与int类似，long是有符号类型。</p>
<p>long long int或long long（C99标准加入）占用的储存空间可能比long多，适用于更大数值的场合。该类型至少占64位。与int类似，long long是有符号类型。</p>
<p>unsigned int或unsigned只用于非负值的场合。这种类型与有符号类型表示的范围不同。例如，16位unsigned int允许的取值范围是0～65535，而不是-32768～32767。用于表示正负号的位现在用于表示另一个二进制位，所以无符号整型可以表示更大的数。</p>
<p>在C90标准中，添加了unsigned long int或unsigned long和unsigned int或unsigned short类型。C99标准又添加了unsigned long long int或unsigned long long。</p>
<p>在任何有符号类型前面添加关键字signed，可强调使用有符号类型的意图。例如，short、short int、signed short、signed short int都表示同一种类型。</p>
<h5 id="声明其他整数类型"><a href="#声明其他整数类型" class="headerlink" title="声明其他整数类型"></a>声明其他整数类型</h5><p>其他整数类型的声明方式与int类型相同。</p>
<p>特殊声明类似unsigned long headcount,unsigned short yesvotes,long long ago不是所有C编译器都能识别，最后一个例子是C99标准新增的。</p>
<h5 id="使用多种整数类型的原因"><a href="#使用多种整数类型的原因" class="headerlink" title="使用多种整数类型的原因"></a>使用多种整数类型的原因</h5><p>简而言之是为了适应不同的机器。</p>
<p>选择int类型的考虑：<br>首先，考虑<em>unsigned</em>类型。这种类型的数常用于计数，因为计数不用负数。而且，unsigned类型可以表示更大的正数。<br>如果一个数超出了int类型的取值范围，且在long类型的取值范围内时，使用<em>long</em>类型。然而，对于那些long占用的空间比int大的系统，使用long类型会减慢运算速度。因此，如非必要，请不要使用long类型。另外要注意一点：如果在long类型和int类型占用空间相同的机器上编写代码，当确实需要32位的整数时，应使用long类型而不是int类型，以便把程序移植到16位机后仍然可以正常工作。类似地，如果确实需要64位的整数，应使用long long类型。<br>如果在int设置为32位的系统中要使用16位的值，应使用<em>short</em>类型以节省存储空间。通常，只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题。使用short类型的另一个原因是，计算机中某些组件使用的硬件寄存器是16位。</p>
<h5 id="long常量和long-long常量"><a href="#long常量和long-long常量" class="headerlink" title="long常量和long long常量"></a>long常量和long long常量</h5><p>通常，程序代码中使用的数字都被储存为int类型。如果使用1000000这样的大数字，超出了int类型能表示的范围，编译器会将其视为long int类型（假设这种类型可以表示该数字）。如果数字超出long可表示的最大值，编译器则将其视为unsigned long类型。如果还不够大，编译器则将其视为long long或unsigned long long类型（前提是编译器能识别这些类型）。</p>
<p>八进制和十六进制常量被视为int类型。如果值太大，编译器会尝试使用unsigned int。如果还不够大，编译器会依次使用long、unsigned long、long long和unsigned long long类型。</p>
<p>有些情况下，需要编译器以long类型储存一个小数字。例如，编程时要显式使用IBM PC上的内存地址时。另外，一些C标准函数也要求使用long类型的值。</p>
<p>要把一个较小的常量作为long类型对待，可以在值的末尾加上l（小写的L）或L后缀。使用L后缀更好，因为l看上去和数字1很像。因此，在int为16位、long为32位的系统中，会把7作为16位储存，把7L作为32位储存。</p>
<p>l或L后缀也可用于八进制和十六进制整数，如020L和0x10L。类似地，在支持long long类型的系统中，也可以使用ll或LL后缀来表示long long类型的值，如3LL。</p>
<p>另外，u或U后缀表示unsigned long long，如5ull、10LLU、6LLU或9Ull。</p>
<p><strong>整数溢出</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* toobig.c-- 超出系统允许的最大int值*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">2147483647</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">4294967295</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, i, i+<span class="number">1</span>, i+<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%u %u %u\n&quot;</span>, j, j+<span class="number">1</span>, j+<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，printf()函数使用%u说明显示unsigned int类型的值。</p>
<p>在我们的系统下输出的结果是：<br>2147483647 -2147483648 -2147483647<br>4294967295 0 1</p>
<p>当无符号整数j达到它能表示的最大值时，会重新从起始点开始。整数 i 也是类似的情况。它们主要的区别是，在超过最大值时，unsigned int 类型的变量 j 从 0开始；而int类型的变量i则从−2147483648开始。注意，当i超出（溢出）其相应类型所能表示的最大值时，系统并未通知用户。</p>
<p>溢出行为是未定义的行为，C 标准并未定义有符号类型的溢出规则。以上描述的溢出行为比较有代表性，但是也可能会出现其他情况。</p>
<h5 id="打印short、long、long-long和unsigned类型"><a href="#打印short、long、long-long和unsigned类型" class="headerlink" title="打印short、long、long long和unsigned类型"></a>打印short、long、long long和unsigned类型</h5><p>打印long类型的值，使用%ld转换说明。如果系统中int和long的大小相同，使用%d就行。但是，这样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工作。在x和o前面可以使用l前缀，%lx表示以十六进制格式打印long类型整数，%lo表示以八进制格式打印long类型整数。注意，虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写。</p>
<p>C语言有多种printf()格式。对于short类型，可以使用h前缀。%hd表示以十进制显示short类型的整数，%ho表示以八进制显示short类型的整数。h和l前缀都可以和u一起使用，用于表示无符号类型。例如，%lu表示打印unsigned long类型的值。对于支持long long类型的系统，%lld和%llu分别表示有符号和无符号类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* print2.c--更多printf()的特性 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="number">3000000000</span>; <span class="comment">/* int为32位和short为16位的系统 */</span></span><br><span class="line">	<span class="keyword">short</span> end = <span class="number">200</span>;</span><br><span class="line">	<span class="keyword">long</span> big = <span class="number">65537</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> verybig = <span class="number">12345678908642</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;un = %u and not %d\n&quot;</span>, un, un);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;end = %hd and %d\n&quot;</span>, end, end);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;big = %ld and not %hd\n&quot;</span>, big, big);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;verybig= %lld and not %ld\n&quot;</span>, verybig, verybig);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在特定的系统中输出如下（输出的结果可能不同）：<br>un = 3000000000 and not -1294967296<br>end = 200 and 200<br>big = 65537 and not 1<br>verybig= 12345678908642 and not 1942899938</p>
<p>第1行输出，对于无符号变量 un，使用%d会生成负值！其原因是，无符号值 3000000000和有符号值−129496296在系统内存中的内部表示完全相同。因此，如果告诉printf()该数是无符号数，它打印一个值；如果告诉它该数是有符号数，它将打印另一个值。在待打印的值大于有符号值的最大值时，会发生这种情况。</p>
<p>第2行输出，对于short类型的变量end，在printf()中无论指定以short类型（%hd）还是int类型（%d）打印，打印出来的值都相同。这是因为在给函数传递参数时，C编译器把short类型的值自动转换成int类型的值。int类型被认为是计算机处理整数类型时最高效的类型。因此，在short和int类型的大小不同的计算机中，用int类型的参数传递速度更快，所以C编译器把short类型的值自动转换成int类型的值。而使用h修饰符可以显示较大整数被截断成 short 类型值的情况。</p>
<p>第 3 行输出就演示了这种情况。把 65537 以二进制格式写成一个 32 位数是00000000000000010000000000000001。使用%hd，printf()只会查看后 16位，所以显示的值是 1。</p>
<p>与此类似，输出的最后一行先显示了verybig的完整值，然后由于使用了%ld，printf()只显示了储存在后32位的值。</p>
<p>==建议：在使用 printf()函数时，切记检查每个待打印值都有对应的转换说明，还要检查转换说明的类型是否与待打印值的类型相匹配。==</p>
<h3 id="使用字符：char类型"><a href="#使用字符：char类型" class="headerlink" title="使用字符：char类型"></a>使用字符：char类型</h3><p>char类型用于储存字符（如，字母或标点符号），但是从技术层面看，char是整数类型。因为char类型实际上储存的是整数而不是字符。计算机使用数字编码来处理字符，即用特定的整数表示特定的字符。最常用的编码是ASCII编码，许多IBM的大型主机使用另一种编码——EBCDIC，其原理相同。另外，其他国家的计算机系统可能使用完全不同的编码。</p>
<p>标准ASCII码的范围是0～127，只需7位二进制数即可表示。通常，char类型被定义为8位的存储单元，因此容纳标准ASCII码绰绰有余。许多其他系统（如IMB PC和苹果Macs）还提供扩展ASCII码，也在8位的表示范围之内。一般而言，C语言会保证char类型足够大，以储存系统（实现C语言的系<br>统）的基本字符集。</p>
<p>许多字符集都超过了127，甚至多于255。</p>
<p>C语言把1字节定义为char类型占用的位（bit）数，因此无论是16位还是<br>32位系统，都可以使用char类型。</p>
<h5 id="声明char类型变量"><a href="#声明char类型变量" class="headerlink" title="声明char类型变量"></a>声明char类型变量</h5><p>char 变量名</p>
<h5 id="字符常量和初始化"><a href="#字符常量和初始化" class="headerlink" title="字符常量和初始化"></a>字符常量和初始化</h5><p>如果要把一个字符常量初始化为字母 A，通过以下初始化把字母A赋给grade即可：char grade = ‘A’;</p>
<p>在C语言中，用单引号括起来的单个字符被称为<strong>字符常量</strong>（characterconstant）。编译器一发现’A’，就会将其转换成相应的代码值。</p>
<p>一些例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> broiled; <span class="comment">/* 声明一个char类型的变量 */</span></span><br><span class="line">broiled = <span class="string">&#x27;T&#x27;</span>; <span class="comment">/* 为其赋值，正确 */</span></span><br><span class="line">broiled = T; <span class="comment">/* 错误！此时T是一个变量 */</span></span><br><span class="line">broiled = <span class="string">&quot;T&quot;</span>; <span class="comment">/* 错误！此时&quot;T&quot;是一个字符串 */</span></span><br></pre></td></tr></table></figure>
<p>实际上，字符是以数值形式储存的，所以也可使用数字代码值来赋值。</p>
<p>由于65是字母A对应的ASCII码，因此本例是把A赋给grade。注意，能这样做的前提是系统使用ASCII码。其实，用’A’代替65才是较为妥当的做法，这样在任何系统中都不会出问题。因此，最好使用字符常量，而不是数字代码值。</p>
<p>==建议：当要把一个字符常量初始化为某个字符时，直接用char 变量名=’字符’，而不是用char 变量名=字符对应的编码==</p>
<p>奇怪的是，C语言将字符常量视为int类型而非char类型。例如，在int为32位、char为8位的ASCII系统中，有下面的代码：<br>char grade = ‘B’;<br>本来’B’对应的数值66储存在32位的存储单元中，现在却可以储存在8位的存储单元中（grade）。利用字符常量的这种特性，可以定义一个字符常量’FATE’，即把4个独立的8位ASCII码储存在一个32位存储单元中。如果把这样的字符常量赋给char类型变量grade，只有最后8位有效。因此，grade的值是’E’。<br><img src="https://img-blog.csdnimg.cn/20201111204306870.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="ASCII字符代码表 一"></p>
<h5 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h5><p>单引号只适用于字符、数字和标点符号，浏览ASCII表会发现，有些ASCII字符打印不出来。例如，一些代表行为的字符（如，退格、换行、终端响铃或蜂鸣）。C语言提供了3种方法表示这些字符。<br>第1种方法是使用ASCII码。</p>
<p>第2种方法是，使用特殊的符号序列表示一些特殊的字符。这些符号序列叫作转义序列（escape sequence）。<br><img src="https://img-blog.csdnimg.cn/20201111205107452.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="转义序列"><br>把转义序列赋给字符变量时，必须用单引号把转义序列括起来，例如char nerf = ‘\n’。</p>
<p>使用C90新增的警报字符（\a）是否能产生听到或看到的警报，取决于计算机的硬件，蜂鸣是最常见的警报（在一些系统中，警报字符不起作用）。C标准规定警报字符不得改变活跃位置。标准中的活跃位置（active position）指的是显示设备（屏幕、电传打字机、打印机等）中下一个字符将出现的位置。简而言之，平时常说的屏幕光标位置就是活跃位置。在程序中把警报字符输出在屏幕上的效果是，发出一声蜂鸣，但不会移动屏幕光标。</p>
<p>接下来的转义字符\b、\f、\n、\r、\t和\v是常用的输出设备控制字符。了解它们最好的方式是查看它们对活跃位置的影响。换页符（\f）把活跃位置移至下一页的开始处；换行符（\n）把活跃位置移至下一行的开始处；回车符（\r）把活跃位置移动到当前行的开始处；水平制表符（\t）将活跃位置移至下一个水平制表点（通常是第1个、第9个、第17个、第25个等字符位置）；垂直制表符（\v）把活跃位置移至下一个垂直制表点。</p>
<p>这些转义序列字符不一定在所有的显示设备上都起作用。</p>
<p>接下来的3个转义序列（\ \、\ ‘、\ “）用于打印 \ 、 ‘ 、 “ 字符（由于这些字符用于定义字符常量，是printf()函数的一部分，若直接使用它们会造成混乱）。如果打印下面一行内容：<br>Gramps sez, “a \ is a backslash.”<br>应这样编写代码：<br>printf(“Gramps sez, &quot;a \ is a backslash.&quot;\n”);</p>
<p>表中的最后两个转义序列（\0oo和\xhh）是ASCII码的特殊表示。如果要用八进制ASCII码表示一个字符，可以在编码值前面加一个反斜杠（\）并用单引号括起来。例如，如果编译器不识别警报字符（\a），可以使用ASCII码来代替：<br>beep = ‘\007’;<br>可以省略前面的 0，即’\07’甚至’\7’都可以。即使没有前缀 0，编译器在处理这种写法时，仍会解释为八进制。</p>
<p>从C90开始，不仅可以用十进制、八进制形式表示字符常量，C语言还提供了第3种选择——用十六进制形式表示字符常量，即反斜杠后面跟一个x或X，再加上1～3位十六进制数字。例如，Ctrl+P字符的ASCII十六进制码是10（相当于十进制的16），可表示为’\x10’或’\x010’。<br><img src="https://img-blog.csdnimg.cn/20201112204650410.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="int系列类型的常量写法示例"><br>使用ASCII码时，注意数字和数字字符的区别。例如，字符4对应的ASCII码是52。’4’表示字符4，而不是数值4。</p>
<p>上面最后一个例子（printf(“Gramps sez, &quot;a \ is a backslash&quot;&quot;n”），为何没有用单引号把转义序列括起来？无论是普通字符还是转义序列，只要是双引号括起来的字符集合，就无需用单引号括起来。双引号中的字符集合叫作字符串。注意，该例中的其他字符（G、r、a、m、p、s等）都没有用单引号括起来。与此类似，printf(“Hello!\007\n”);将打印Hello!并发出一声蜂鸣，而 printf(“Hello!7\n”);则打印 Hello!7。不是转义序列中的数字将作为普通字符被打印出来。</p>
<p>如果要在转义序列（假设使用’\f’）和ASCII码（’\014’）之间选择，请选择前者（即’\f’）。这样的写法不仅更好记，而且可移植性更高。’\f’在不使用ASCII码的系统中，仍然有效。</p>
<p>如果要使用ASCII码，为何要写成’\032’而不是032？首先，’\032’能更清晰地表达程序员使用字符编码的意图。其次，类似\032这样的转义序列可以嵌入C的字符串中，如printf(“Hello!\007\n”);中就嵌入了\007。</p>
<h5 id="打印字符"><a href="#打印字符" class="headerlink" title="打印字符"></a>打印字符</h5><p>printf()函数用%c指明待打印的字符。如果用%d转换说明打印 char类型变量的值，打印的是一个整数。而%c转换说明告诉printf()打印该整数值对应的字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* charcode.c-显示字符的代码编号 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please enter a character.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch); <span class="comment">/* 用户输入字符 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The code for %c is %d.\n&quot;</span>, ch, ch);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该程序后，输出示例如下：<br>Please enter a character.<br>C<br>The code for C is 67.<br><img src="https://img-blog.csdnimg.cn/202011122119392.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="数据显示和数据存储"><br><strong>有符号还是无符号</strong><br>有些C编译器把char实现为有符号类型，这意味着char可表示的范围是-128～127。而有些C编译器把char实现为无符号类型，那么char可表示的范围是0～255。</p>
<p>根据C90标准，C语言允许在关键字char前面使用signed或unsigned。这样，无论编译器默认char是什么类型，signed char表示有符号类型，而unsigned char表示无符号类型。这在用char类型处理小整数时很有用。如果只用char处理字符，那么char前面无需使用任何修饰符。</p>
<h3 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a>_Bool类型</h3><p>C99标准添加了 <strong>_Bool</strong>类型，用于表示布尔值，即逻辑值<strong>true</strong>和<strong>false</strong>。因为C语言用值<strong>1</strong>表示true，值<strong>0</strong>表示false，所以_Bool类型实际上也是一种<strong>整数</strong>类型。但原则上它仅占用1位存储空间，因为对0和1而言，1位的存储空间足够了。</p>
<p>程序通过布尔值可选择执行哪部分代码。</p>
<h3 id="可移植类型：stdint-h和inttypes-h"><a href="#可移植类型：stdint-h和inttypes-h" class="headerlink" title="可移植类型：stdint.h和inttypes.h"></a>可移植类型：stdint.h和inttypes.h</h3><p>C 语言提供了许多有用的整数类型。但是，某些类型名在不同系统中的功能不一样。C99 新增了两个头文件<strong>stdint.h</strong>和<strong>inttypes.h</strong>，以确保C语言的类型在各系统中的功能相同。</p>
<p>C语言为现有类型创建了更多类型名。这些新的类型名定义在stdint.h头文件中。在使用int、char等数据类型名时，stdint.h会将其用新的类型名替换使其能够与当前系统的位数相匹配。</p>
<p>新类型名如int32_t表示整数类型的宽度正好是32位。这类类型被称为<strong>精确宽度整数类型</strong>（exact-width integer type）。但是，计算机的底层系统可能不支持。因此，精确宽度整数类型是可选项。</p>
<p>如果系统不支持精确宽度整数类型,C99和C11提供了第2类别名集合。一些类型名保证所表示的类型一定是至少有指定宽度的最小整数类型。这组类型集合被称为<strong>最小宽度类型</strong>（minimum width type）。例如，int_least8_t是可容纳8位有符号整数值的类型中宽度最小的类型的一个别名。如果某系统的最小整数类型是16位，可能不会定义int8_t类型。尽管如此，该系统仍可使用int_least8_t类型，但可能把该类型实现为16位的整数类型。</p>
<p>因为一些程序员更关心速度而非空间，C99和C11定义了一组可使计算达到最快的类型集合。这组类型集合被称为<strong>最快最小宽度类型</strong>（fastst minimum width type）。例如，int_fast8_t被定义为系统中对8位有符号值而言运算最快的整数类型的别名。</p>
<p>另外，有些程序员需要<strong>系统的最大整数类型</strong>。为此，C99定义了最大的有符号整数类型intmax_t，可储存任何有效的有符号整数值。类似地，unitmax_t表示最大的无符号整数类型。顺带一提，这些类型有可能比long long和unsigned long类型更大，因为C编译器除了实现标准规定的类型以外，还可利用C语言实现其他类型。</p>
<p>C99 和 C11 不仅提供可移植的类型名，还提供相应的输入和输出。例如，printf()打印特定类型时要求与相应的转换说明匹配。如果要打印int32_t类型的值，因为有些定义使用%d，而有些定义使用%ld，所以C标准针对这一情况，提供了一些字符串宏来显示可移植类型。例如， inttypes.h头文件中定义了PRId32字符串宏，代表打印32位有符号值的合适转换说明（如d或l）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* altnames.c -- 可移植整数类型名 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span> <span class="comment">// 支持可移植类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int32_t</span> me32; <span class="comment">// me32是一个32位有符号整型变量</span></span><br><span class="line">	me32 = <span class="number">45933945</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;First, assume int32_t is int: &quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;me32 = %d\n&quot;</span>, me32);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Next, let&#x27;s not make any assumptions.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Instead, use a \&quot;macro\&quot; from inttypes.h: &quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;me32 = %&quot;</span> PRId32 <span class="string">&quot;\n&quot;</span>, me32);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是该程序的输出，注意，程序中使用了\ “转义序列来显示双引号：<br>First, assume int32_t is int: me32 = 45933945<br>Next, let’s not make any assumptions.<br>Instead, use a “macro” from inttypes.h: me32 = 45933945</p>
<p>其中最后一个printf()函数中的 <strong>“”</strong> 起连接字符串的作用(CSDN默认将英文双引号视为中文双引号)。</p>
<h3 id="float、double和long-double"><a href="#float、double和long-double" class="headerlink" title="float、double和long double"></a>float、double和long double</h3><p>C语言中的浮点类型有<strong>float</strong>、<strong>double</strong>和<strong>long double</strong>类型。</p>
<p>浮点类型能表示包括小数在内更大范围的数。浮点数的表示类似于科学记数法（即用小数乘以10的幂来表示数字）。该记数系统常用于表示非常大或非常小的数。<br><img src="https://img-blog.csdnimg.cn/20201114221333406.bmp#pic_center" alt="记数法示例"><br>C标准规定，<strong>float</strong>类型必须至少能表示6位有效数字，且取值范围至少是10^-37 ～ 10^+37。</p>
<p>通常，系统储存一个浮点数要占用32位。其中8位用于表示指数的值和符号，剩下24位用于表示非指数部分（也叫作尾数或有效数）及其符号。</p>
<blockquote>
<p><strong>拓展</strong>：<br>根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式：<br>V = (-1)^s × M × 2^E<br>（1）(-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。<br>（2）尾数M表示有效数字，大于等于1，小于2。<br>（3）2^E表示指数。<br>“尾数”又可称之为“精度”，即对表达结果的精确程度产生重要影响的数。1≤M&lt;2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。</p>
<p><img src="https://img-blog.csdnimg.cn/20201114221557441.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70#pic_center" alt="更多浮点数写法示例"><br>C语言提供的另一种浮点类型是<strong>double</strong>（意为双精度）。double类型和float类型的最小取值范围相同，但至少必须能表示10位有效数字。</p>
</blockquote>
<p>一般情况下，double占用64位而不是32位。一些系统将多出的 32 位全部用来表示非指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了舍入误差。另一些系统把其中的一些位分配给指数部分，以容纳更大的指数，从而增加了可表示数的范围。</p>
<p>无论哪种方法，double类型的值至少有13位有效数字，超过了标准的最低位数规定。</p>
<p>C语言的第3种浮点类型是<strong>long double</strong>，以满足比double类型更高的精度要求。不过，C只保证long double类型至少与double类型的精度相同。</p>
<h5 id="声明浮点型变量"><a href="#声明浮点型变量" class="headerlink" title="声明浮点型变量"></a>声明浮点型变量</h5><h5 id="浮点型常量"><a href="#浮点型常量" class="headerlink" title="浮点型常量"></a>浮点型常量</h5><p>浮点型常量的基本形式是：有符号的数字（包括小数点），后面紧跟e或E，最后是一个有符号数表示10的指数。</p>
<p>正号可以省略。可以没有小数点（如，2E5）或指数部分（如，19.28），但是不能同时省略两者。可以省略小数部分（如，3.E16）或整数部分（如，.45E-6），但是不能同时省略两者。</p>
<p>不能在浮点型常量中间加空格。</p>
<p>默认情况下，编译器假定浮点型常量是double类型的精度。</p>
<p>通常，声明的常量被储存为64位的double类型，使用双精度进行乘法运算，然后将乘积截断成float类型的宽度。这样做虽然计算精度更高，但是会减慢程序的运行速度。</p>
<p>在浮点数后面加上f或F后缀可覆盖默认设置，编译器会将浮点型常量看作float类型，如2.3f和9.11E9F。使用l或L后缀使得数字成为long double类型，如54.3l和4.32L。没有后缀的浮点型常量是double类型。</p>
<p>==建议:使用L而不是l，因为l与1容易混淆。==</p>
<p>C99 标准添加了一种新的浮点型常量格式——用十六进制表示浮点型常量，即在十六进制数前加上十六进制前缀（0x或0X），用p和P分别代替e和E，用2的幂代替10的幂（即，p计数法）。</p>
<h5 id="打印浮点值"><a href="#打印浮点值" class="headerlink" title="打印浮点值"></a>打印浮点值</h5><p>printf()函数使用%f转换说明打印十进制记数法的float和double类型浮点数，用%e打印指数记数法的浮点数。</p>
<p>如果系统支持十六进制格式的浮点数，可用a和A分别代替e和E。</p>
<p>打印long double类型要使用%Lf、%Le或%La转换说明。</p>
<p>给那些未在函数原型中显式说明参数类型的函数（如，printf()）传递参数时，C编译器会把float类型的值自动转换成double类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* showf_pt.c -- 以两种方式显示float类型的值 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> aboat = <span class="number">32000.0</span>;</span><br><span class="line">	<span class="keyword">double</span> abet = <span class="number">2.14e9</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">double</span> dip = <span class="number">5.32e-5</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f can be written %e\n&quot;</span>, aboat, aboat);</span><br><span class="line">	<span class="comment">// 下一行要求编译器支持C99或其中的相关特性</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;And it&#x27;s %a in hexadecimal, powers of 2 notation\n&quot;</span>,</span><br><span class="line">	aboat);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f can be written %e\n&quot;</span>, abet, abet);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%Lf can be written %Le\n&quot;</span>, dip, dip);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的输出如下，前提是编译器支持C99/C11：<br>32000.000000 can be written 3.200000e+04<br>And it’s 0x1.f4p+14 in hexadecimal, powers of 2 notation<br>2140000000.000000 can be written 2.140000e+09<br>0.000053 can be written 5.320000e-05</p>
<h5 id="浮点值的上溢和下溢"><a href="#浮点值的上溢和下溢" class="headerlink" title="浮点值的上溢和下溢"></a>浮点值的上溢和下溢</h5><p>当计算导致数字过大，超过当前类型能表达的范围时，就会发生<strong>上溢</strong>。这种行为在过去是未定义的，不过现在C语言规定，在这种情况下会给toobig赋一个表示无穷大的特定值，而且printf()显示该值为inf或infinity（或者具有无穷含义的其他内容）。</p>
<p>虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫作<strong>下溢</strong>（underflow）。</p>
<p>当用一个小的浮点值除以一个值时容易发生下溢。浮点数以指数和尾数部分来存储，其中指数的位置在尾数前。当发生下溢时，浮点数的存储位置（尾数部分存储位置）右移一位，即丢失一个二进制位，空出一个二进制位，而指数位置不变，因此指数不变，如，0.1234E-10除以10，得到的结果是0.0123E-10。</p>
<p>C语言把损失了类型全精度的浮点值称为<strong>低于正常的</strong>（subnormal）<strong>浮点值</strong>。因此，把最小的正浮点数除以2将得到一个低于正常的值。如果除以一个非常大的值，会导致所有的位都为0。</p>
<p>C语言存在一个特殊的浮点值<strong>NaN</strong>（not a number的缩写）。当传入函数的参数不被函数定义时，函数会返回NaN值。printf()函数可将其显示为nan、NaN或其他类似的内容。</p>
<p><strong>浮点数舍入错误</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* floaterr.c--演示舍入错误 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> a,b;</span><br><span class="line">b = <span class="number">2.0e20</span> + <span class="number">1.0</span>;</span><br><span class="line">a = b - <span class="number">2.0e20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f \n&quot;</span>, a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的输出如下：<br>0.000000←Linux系统下的老式系统gcc<br>-13584010575872.000000←Turbo c 1.5<br>4008175468544.000000←XCode 4.5、Visual Studio 2012、当前版本的gcc</p>
<p>发生输出异常的原因为计算机缺少足够的小数位来完成正确的运算。float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字，而该程序要求至少储存21位的数字，即float提供的精度不够。</p>
<p><strong>浮点数表示法</strong><br>实现浮点数表示法的方法有多种。在之前，由于计算机使用系统的不同，一个程序可能有不同的输出。为了尽可能地统一实现，电子和电气工程师协会（IEEE）为浮点数计算和表示法开发了一套标准。现在，许多硬件浮点单元都采用该标准。</p>
<h3 id="复数和虚数类型"><a href="#复数和虚数类型" class="headerlink" title="复数和虚数类型"></a>复数和虚数类型</h3><p>C语言有3种复数类型：<strong>float_Complex</strong>、<strong>double_Complex</strong>和<strong>long double _Complex</strong>。例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部。类似地， C语言的3种虚数类型是<strong>float_Imaginary</strong>、<strong>double _Imaginary</strong>和<strong>long double _Imaginary</strong>。</p>
<p>如果包含<strong>complex.h</strong>头文件，便可用complex代替_Complex，用imaginary代替_Imaginary，还可以用I代替-1的平方根。不直接用 complex 作为关键字来代替_Complex的原因是如果使用新的关键字，会导致以该关键字作为标识符的现有代码全部失效。</p>
<h3 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h3><p>C语言还有一些从基本类型衍生的其他类型，包括数组、指针、结构和联合。</p>
<h4 id="小结：基本数据类型"><a href="#小结：基本数据类型" class="headerlink" title="小结：基本数据类型"></a>小结：基本数据类型</h4><p><strong>关键字</strong>：<br>基本数据类型由11个关键字组成：int、long、short、unsigned、char、float、double、signed、_Bool、_Complex和_Imaginary。</p>
<p><strong>有符号整型</strong>：<br>有符号整型可用于表示正整数和负整数。</p>
<p>int ——系统给定的基本整数类型。C语言规定int类型不小于16位。</p>
<p>short或short int ——最大的short类型整数小于或等于最大的int类型整数。C语言规定short类型至少占16位。</p>
<p>long或long int ——该类型可表示的整数大于或等于最大的int类型整数。C语言规定long类型至少占32位。</p>
<p>long long或long long int ——该类型可表示的整数大于或等于最大的long类型整数。Long long类型至少占64位。</p>
<p>一般而言，long类型占用的内存比short类型大，int类型的宽度要么和long类型相同，要么和short类型相同。例如，旧DOS系统的PC提供16位的short和int，以及32位的long；Windows 95系统提供16位的short以及32位的int和long。</p>
<p><strong>无符号整型</strong>：<br>无符号整型只能用于表示零和正整数，因此无符号整型可表示的正整数比有符号整型的大。在整型类型前加上关键字unsigned表明该类型是无符号整型：unsignedint、unsigned long、unsigned short。单独的unsigned相当于unsignedint。</p>
<p><strong>字符类型</strong>：<br>可打印出来的符号（如A、&amp;和+）都是字符。根据定义，char类型表示一个字符要占用1字节内存。出于历史原因，1字节通常是8位，但是如果要表示基本字符集，也可以是16位或更大。</p>
<p>char ——字符类型的关键字。有些编译器使用有符号的char，而有些则使用无符号的char。在需要时，可在char前面加上关键字signed或unsigned来指明具体使用哪一种类型。</p>
<p><strong>布尔类型</strong>：<br>布尔值表示true和false。C语言用1表示true，0表示false。<br>_Bool ——布尔类型的关键字。布尔类型是无符号 int类型，所占用的空间只要能储存0或1即可。</p>
<p><strong>实浮点类型</strong>：<br>实浮点类型可表示正浮点数和负浮点数。</p>
<p>float ——系统的基本浮点类型，可精确表示至少6位有效数字。</p>
<p>double ——储存浮点数的范围（可能）更大，能表示比 float 类型更多的有效数字（至少 10位，通常会更多）和更大的指数。</p>
<p>long long ——储存浮点数的范围（可能）比double更大，能表示比double更多的有效数字和更大的指数。</p>
<p><strong>复数和虚数浮点数</strong>：<br>虚数类型是可选的类型。复数的实部和虚部类型都基于实浮点类型来构成：<br>float _Complex<br>double _Complex<br>long double _Complex<br>float _Imaginary<br>double _Imaginary<br>long long _Imaginary</p>
<h4 id="小结：如何声明简单变量"><a href="#小结：如何声明简单变量" class="headerlink" title="小结：如何声明简单变量"></a>小结：如何声明简单变量</h4><p>1.选择需要的类型。</p>
<p>2.使用有效的字符给变量起一个变量名。</p>
<p>3.按以下格式进行声明：<br>类型说明符 变量名;<br>类型说明符由一个或多个关键字组成。</p>
<p>4.可以同时声明相同类型的多个变量，用逗号分隔各变量名，如下所<br>示：<br>char ch, init, ans;</p>
<p>5.在声明的同时还可以初始化变量：<br>float mass = 6.0E24;</p>
<h3 id="类型大小"><a href="#类型大小" class="headerlink" title="类型大小"></a>类型大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* typesize.c -- 打印类型大小 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* C99为类型大小提供%zd转换说明 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Type int has a size of %zd bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Type char has a size of %zd bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Type long has a size of %zd bytes.\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Type long long has a size of %zd bytes.\n&quot;</span>,</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Type double has a size of %zd bytes.\n&quot;</span>,</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Type long double has a size of %zd bytes.\n&quot;</span>,</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的输出如下：<br>Type int has a size of 4 bytes.<br>Type char has a size of 1 bytes.<br>Type long has a size of 8 bytes.<br>Type long long has a size of 8 bytes.<br>Type double has a size of 8 bytes.<br>Type long double has a size of 16 bytes.</p>
<p><strong>sizeof</strong>是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型。一些不支持C99和C11的编译器可用%u或%lu代替%zd。</p>
<hr>
<h2 id="使用数据类型"><a href="#使用数据类型" class="headerlink" title="使用数据类型"></a>使用数据类型</h2><p>编写程序时，应注意合理选择所需的变量及其类型。</p>
<p>在使用变量之前必须先声明，并选择有意义的变量名。初始化变量应使用与变量类型匹配的常数类型。</p>
<p>把一个类型的数值初始化给不同类型的变量时，编译器会把值转换成与变量匹配的类型，这将导致部分数据丢失。如，用double类型值初始化int类型变量会使值丢失小数部分，用double类型值初始化float类型变量会使值丢失小数部分前6位外的值。</p>
<p>许多程序员和公司内部都有系统化的命名约定，在变量名中体现其类型。例如，用 i_前缀表示 int类型，us_前缀表示 unsigned short 类型。</p>
<hr>
<h2 id="参数和陷阱"><a href="#参数和陷阱" class="headerlink" title="参数和陷阱"></a>参数和陷阱</h2><p>传递给函数的信息被称为参数。</p>
<p>理解无论双引号中包含多少个字符和标点符号，一个字符串就是一个参数。</p>
<p>C语言用逗号分隔函数中的参数。</p>
<p>printf()和scanf()函数与一般函数不同，它们的参数个数是可变的。printf()和scanf()函数用第1个参数表明后续有多少个参数，即第1个字符串中的转换说明与后面的参数一一对应。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* badcount.c -- 参数错误的情况 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">float</span> f = <span class="number">7.0f</span>;</span><br><span class="line">	<span class="keyword">float</span> g = <span class="number">8.0f</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n, m); <span class="comment">/* 参数太多 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, n); <span class="comment">/* 参数太少 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, f, g); <span class="comment">/* 值的类型不匹配 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>XCode 4.6（OS 10.8）的输出如下：<br>4<br>4 1 -706337836<br>1606414344 1</p>
<p>Microsoft Visual Studio Express 2012（Windows 7）的输出如下：<br>4<br>4 0 0<br>0 1075576832</p>
<p>用%d显示float类型的值，其值不会被转换成int类型。</p>
<p>在不同的平台下，缺少参数或参数类型不匹配导致的结果不同。</p>
<hr>
<h2 id="转义序列示例"><a href="#转义序列示例" class="headerlink" title="转义序列示例"></a>转义序列示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* escape.c -- 使用转移序列 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> salary;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\aEnter your desired monthly salary:&quot;</span>); <span class="comment">/* 1 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; $_______\b\b\b\b\b\b\b&quot;</span>); <span class="comment">/* 2 */</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;salary);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\t$%.2f a month is $%.2f a year.&quot;</span>, salary,</span><br><span class="line">	salary * <span class="number">12.0</span>); <span class="comment">/* 3 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\rGee!\n&quot;</span>); <span class="comment">/* 4 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序含有响铃(\a)、退格（\b）、换行(\n)、水平制表符（\t，横向跳到下一制表位置，一般是在第9列）和回车（\r，将当前位置移到本行开头）。</p>
<h3 id="程序运行情况"><a href="#程序运行情况" class="headerlink" title="程序运行情况"></a>程序运行情况</h3><p>假设输入4000.00，则程序输出如下：<br>Enter your desired monthly salary: $4000.00<br>Gee! $4000.00 a month is $48000.00 a year.</p>
<h3 id="刷新输出"><a href="#刷新输出" class="headerlink" title="刷新输出"></a>刷新输出</h3><p>最初，printf()语句把输出发送到一个叫作缓冲区（buffer）的中间存储区域，然后缓冲区中的内容再不断被发送到屏幕上。C 标准明确规定了何时把缓冲区中的内容发送到屏幕：当缓冲区满、遇到换行字符或需要输入的时候（从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区）。</p>
<p>旧式编译器遇到scanf()也不会强行刷新缓冲区，程序会停在那里不显示任何提示内容，等待用户输入数据。在这种情况下，可以使用换行字符刷新缓冲区。</p>
<p>无论接下来的输入是否能刷新缓冲区，代码都会正常运行。这将导致光标移至下一行起始处，用户无法在提示内容同一行输入数据。</p>
<p>还有一种刷新缓冲区的方法是使用fflush()函数。</p>
<hr>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><p>C语言提供了大量的数值类型，目的是为程序员提供方便。</p>
<p>计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大区别。</p>
<p>C语言允许编写混合数据类型的表达式，但是会进行自动类型转换，以便在实际运算时统一使用一种类型。</p>
<p>计算机在内存中用数值编码来表示字符。美国最常用的是ASCII码，除此之外C也支持其他编码。</p>
<p>字符常量是计算机系统使用的数值编码的符号表示，它表示为单引号括起来的字符。</p>
<hr>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>C 有多种的数据类型。基本数据类型分为两大类：整数类型和浮点数类型。</p>
<p>通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型。最小的整数类型是char，因实现不同，可以是有符号的char或无符号的char，即unsigned char或signed char。但是，通常用char类型表示小整数时才这样显示说明。其他整数类型有short、int、long和long long类型。C规定，后面的类型不能小于前面的类型。上述都是有符号类型，但也可以使用unsigned关键字创建相应的无符号类型：unsigned short、unsigned int、unsigned long和unsigned long long。或者，在类型名前加上signed修饰符显式表明该类型是有符号类型。最后，_Bool类型是一种无符号类型，可储存0或1，分别代表false和true。</p>
<p>浮点类型有3种：float、double和C90新增的long double。后面的类型应大于或等于前面的类型。有些实现可选择支持复数类型和虚数类型，通过关键字_Complex和_Imaginary与浮点类型的关键字组合（如，double _Complex类型和float _Imaginary类型）来表示这些类型。</p>
<p>整数可以表示为十进制、八进制或十六进制。0前缀表示八进制数，0x或0X前缀表示十六进制数。例如，32、040、0x20分别以十进制、八进制、十六进制表示同一个值。l或L前缀表明该值是long类型， ll或LL前缀表明该值是long long类型。</p>
<p>在C语言中，直接表示一个字符常量的方法是：把该字符用单引号括起来，如’Q’、’8’和’$’。C语言的转义序列（如，’\n’）表示某些非打印字符。另外，还可以在八进制或十六进制数前加上一个反斜杠（如，’\007’），表示ASCII码中的一个字符。</p>
<p>浮点数可写成固定小数点的形式（如，9393.912）或指数形式（如，7.38E10）。C99和C11提供了第3种指数表示法，即用十六进制数和2的幂来表示（如，0xa.1fp10）。</p>
<p>printf()函数根据转换说明打印各种类型的值。转换说明最简单的形式由一个百分号（%）和一个转换字符组成，如%d或%f。</p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">天了噜Rex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/17/%E3%80%8AC%20Primer%20Plus%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%92%8CC/">http://example.com/2021/11/17/%E3%80%8AC%20Primer%20Plus%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%92%8CC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/17/%E3%80%8AC%20Primer%20Plus%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">《C Primer Plus》学习笔记_第四章 字符串和格式化输入/输出</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/17/%E3%80%8AC%20Primer%20Plus%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">《C Primer Plus》学习笔记_第二章 C语言概述</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">天了噜Rex</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">29</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Phantasm-of-Observer"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">某王姓男子的杂物堆（个人博客），欢迎各位来访orz！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%92%8CC"><span class="toc-number">1.</span> <span class="toc-text">第3章 数据和C</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">示例程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%96%B0%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.1.</span> <span class="toc-text">程序中的新元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.</span> <span class="toc-text">变量与常量数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.</span> <span class="toc-text">数据：数据类型关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">整数和浮点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">浮点数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">C语言基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#int%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">int类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8Eint%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.1.0.1.</span> <span class="toc-text">声明int变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.1.0.2.</span> <span class="toc-text">初始化变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F"><span class="toc-number">1.4.1.0.3.</span> <span class="toc-text">int类型常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E5%8D%B0int%E5%80%BC"><span class="toc-number">1.4.1.0.4.</span> <span class="toc-text">打印int值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AB%E8%BF%9B%E5%88%B6%E5%92%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6"><span class="toc-number">1.4.1.0.5.</span> <span class="toc-text">八进制和十六进制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%85%AB%E8%BF%9B%E5%88%B6%E5%92%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6"><span class="toc-number">1.4.1.0.6.</span> <span class="toc-text">显示八进制和十六进制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">其他整数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%85%B6%E4%BB%96%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.2.0.1.</span> <span class="toc-text">声明其他整数类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.4.2.0.2.</span> <span class="toc-text">使用多种整数类型的原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#long%E5%B8%B8%E9%87%8F%E5%92%8Clong-long%E5%B8%B8%E9%87%8F"><span class="toc-number">1.4.2.0.3.</span> <span class="toc-text">long常量和long long常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E5%8D%B0short%E3%80%81long%E3%80%81long-long%E5%92%8Cunsigned%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.2.0.4.</span> <span class="toc-text">打印short、long、long long和unsigned类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%EF%BC%9Achar%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">使用字符：char类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8Echar%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.3.0.1.</span> <span class="toc-text">声明char类型变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.3.0.2.</span> <span class="toc-text">字符常量和初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6"><span class="toc-number">1.4.3.0.3.</span> <span class="toc-text">非打印字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6"><span class="toc-number">1.4.3.0.4.</span> <span class="toc-text">打印字符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bool%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">_Bool类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%B1%BB%E5%9E%8B%EF%BC%9Astdint-h%E5%92%8Cinttypes-h"><span class="toc-number">1.4.5.</span> <span class="toc-text">可移植类型：stdint.h和inttypes.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#float%E3%80%81double%E5%92%8Clong-double"><span class="toc-number">1.4.6.</span> <span class="toc-text">float、double和long double</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.6.0.1.</span> <span class="toc-text">声明浮点型变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%B8%B8%E9%87%8F"><span class="toc-number">1.4.6.0.2.</span> <span class="toc-text">浮点型常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%AE%E7%82%B9%E5%80%BC"><span class="toc-number">1.4.6.0.3.</span> <span class="toc-text">打印浮点值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%80%BC%E7%9A%84%E4%B8%8A%E6%BA%A2%E5%92%8C%E4%B8%8B%E6%BA%A2"><span class="toc-number">1.4.6.0.4.</span> <span class="toc-text">浮点值的上溢和下溢</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%95%B0%E5%92%8C%E8%99%9A%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.7.</span> <span class="toc-text">复数和虚数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.8.</span> <span class="toc-text">其他类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">小结：基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A%E5%A6%82%E4%BD%95%E5%A3%B0%E6%98%8E%E7%AE%80%E5%8D%95%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">小结：如何声明简单变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.4.9.</span> <span class="toc-text">类型大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">使用数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%92%8C%E9%99%B7%E9%98%B1"><span class="toc-number">1.6.</span> <span class="toc-text">参数和陷阱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.7.</span> <span class="toc-text">转义序列示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">程序运行情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E8%BE%93%E5%87%BA"><span class="toc-number">1.7.2.</span> <span class="toc-text">刷新输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.</span> <span class="toc-text">关键概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-number">1.9.</span> <span class="toc-text">本章小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E7%BF%BB%E8%AF%91%E3%80%8BGetting%20Started%20-%20Glossary/" title="《Substrate Docs翻译》Getting Started - Glossary"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Substrate Docs翻译》Getting Started - Glossary"/></a><div class="content"><a class="title" href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E7%BF%BB%E8%AF%91%E3%80%8BGetting%20Started%20-%20Glossary/" title="《Substrate Docs翻译》Getting Started - Glossary">《Substrate Docs翻译》Getting Started - Glossary</a><time datetime="2021-12-03T07:05:48.000Z" title="Created 2021-12-03 15:05:48">2021-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E7%BF%BB%E8%AF%91%E3%80%8BGetting%20Started%20-%20Getting%20Started%20on%20Windows/" title="《Substrate Docs翻译》Getting Started - Getting Started on Windows"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Substrate Docs翻译》Getting Started - Getting Started on Windows"/></a><div class="content"><a class="title" href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E7%BF%BB%E8%AF%91%E3%80%8BGetting%20Started%20-%20Getting%20Started%20on%20Windows/" title="《Substrate Docs翻译》Getting Started - Getting Started on Windows">《Substrate Docs翻译》Getting Started - Getting Started on Windows</a><time datetime="2021-12-03T06:48:10.000Z" title="Created 2021-12-03 14:48:10">2021-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E7%BF%BB%E8%AF%91%E3%80%8BGetting%20Started%20-%20Installation/" title="《Substrate Docs翻译》Getting Started - Installation"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Substrate Docs翻译》Getting Started - Installation"/></a><div class="content"><a class="title" href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E7%BF%BB%E8%AF%91%E3%80%8BGetting%20Started%20-%20Installation/" title="《Substrate Docs翻译》Getting Started - Installation">《Substrate Docs翻译》Getting Started - Installation</a><time datetime="2021-12-03T03:47:04.000Z" title="Created 2021-12-03 11:47:04">2021-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E7%BF%BB%E8%AF%91%E3%80%8BGetting%20Started%20-%20Architecture/" title="《Substrate Docs翻译》Getting Started - Architecture"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Substrate Docs翻译》Getting Started - Architecture"/></a><div class="content"><a class="title" href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E7%BF%BB%E8%AF%91%E3%80%8BGetting%20Started%20-%20Architecture/" title="《Substrate Docs翻译》Getting Started - Architecture">《Substrate Docs翻译》Getting Started - Architecture</a><time datetime="2021-12-03T03:21:59.000Z" title="Created 2021-12-03 11:21:59">2021-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E7%BF%BB%E8%AF%91%E3%80%8BGetting%20Started%20-%20Welcome/" title="《Substrate Docs翻译》Getting Started - Welcome"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Substrate Docs翻译》Getting Started - Welcome"/></a><div class="content"><a class="title" href="/2021/12/03/%E3%80%8ASubstrate%20Docs%E7%BF%BB%E8%AF%91%E3%80%8BGetting%20Started%20-%20Welcome/" title="《Substrate Docs翻译》Getting Started - Welcome">《Substrate Docs翻译》Getting Started - Welcome</a><time datetime="2021-12-03T02:59:53.000Z" title="Created 2021-12-03 10:59:53">2021-12-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 天了噜Rex</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>