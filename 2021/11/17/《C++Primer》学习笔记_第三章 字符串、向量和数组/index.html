<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《C++Primer》学习笔记_第三章 字符串、向量和数组.md | 天了噜Rex的杂物堆</title><meta name="author" content="天了噜Rex"><meta name="copyright" content="天了噜Rex"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第3章 字符串、向量和数组本章将介绍两种最重要的标准库类型：string和vector。string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。本章还将介绍内置数组类型。  3.1 命名空间的using声明我们用到的库函数基本上都属于命名空间std。 通过更简单的途径能使用到命名空间中的成员，如使用using声明（using declaration）。 有了using声">
<meta property="og:type" content="article">
<meta property="og:title" content="《C++Primer》学习笔记_第三章 字符串、向量和数组.md">
<meta property="og:url" content="http://example.com/2021/11/17/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="天了噜Rex的杂物堆">
<meta property="og:description" content="第3章 字符串、向量和数组本章将介绍两种最重要的标准库类型：string和vector。string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。本章还将介绍内置数组类型。  3.1 命名空间的using声明我们用到的库函数基本上都属于命名空间std。 通过更简单的途径能使用到命名空间中的成员，如使用using声明（using declaration）。 有了using声">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-11-17T12:28:13.000Z">
<meta property="article:modified_time" content="2021-11-17T12:29:02.323Z">
<meta property="article:author" content="天了噜Rex">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/11/17/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《C++Primer》学习笔记_第三章 字符串、向量和数组.md',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-17 20:29:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">24</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">天了噜Rex的杂物堆</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《C++Primer》学习笔记_第三章 字符串、向量和数组.md</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-11-17T12:28:13.000Z" title="Created 2021-11-17 20:28:13">2021-11-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-11-17T12:29:02.323Z" title="Updated 2021-11-17 20:29:02">2021-11-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《C++Primer》学习笔记_第三章 字符串、向量和数组.md"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h1><p>本章将介绍两种最重要的标准库类型：string和vector。string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。本章还将介绍内置数组类型。</p>
<hr>
<h1 id="3-1-命名空间的using声明"><a href="#3-1-命名空间的using声明" class="headerlink" title="3.1 命名空间的using声明"></a>3.1 命名空间的using声明</h1><p>我们用到的库函数基本上都属于命名空间std。</p>
<p>通过更简单的途径能使用到命名空间中的成员，如使用<strong>using声明（using declaration）</strong>。</p>
<p>有了using声明就无须专门的前缀（形如命名空间：：）也能使用所需的名字了。using声明具有如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure>
<p>一旦声明了上述语句，就可以直接访问命名空间中的名字：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using声明，当我们使用名字cin时，从命名空间std中获取它</span></span><br><span class="line"><span class="keyword">using</span> std::sin;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	cin&gt;&gt;i;			<span class="comment">//正确：cin和std::cin含义相同</span></span><br><span class="line">	cout&lt;&lt;i;		<span class="comment">//错误：没有对应的using声明，必须使用完整的名字</span></span><br><span class="line">	std::cout&lt;&lt;i;	<span class="comment">//正确：显式地从std中使用cout</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="每个名字都需要独立的using声明"><a href="#每个名字都需要独立的using声明" class="headerlink" title="每个名字都需要独立的using声明"></a>每个名字都需要独立的using声明</h4><p>按照规定，每个using声明引入命名空间中的一个成员。</p>
<h4 id="头文件不应包含using声明"><a href="#头文件不应包含using声明" class="headerlink" title="头文件不应包含using声明"></a>头文件不应包含using声明</h4><p>头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p>
<hr>
<h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><p>标准库类型<strong>string</strong>表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::string;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h3><p>初始化string对象最常用的一些方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1;			<span class="comment">//默认初始化，s1是一个空字符串</span></span><br><span class="line">string s2=s1;		<span class="comment">//s2是s1的副本</span></span><br><span class="line">string s3=<span class="string">&quot;hiya&quot;</span>;	<span class="comment">//s3是该字符串字面值的副本</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)</span></span>;	<span class="comment">//s4的内容是cccccccccc（10个c）</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210324104912945.png" alt="初始化string对象的方式"></p>
<h4 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h4><p>如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化（copy initialization）</strong>。与之相反，如果不使用等号，则执行的是<strong>直接初始化（direct initialization）</strong>。</p>
<p>当初始值只有一个时，使用直接初始化或拷贝初始化都行。如果像s4那样初始化要用到的值有多个，一般来说只能使用直接初始化的方式。</p>
<h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h3><p>一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。<br><img src="https://img-blog.csdnimg.cn/20210324111627694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70" alt="string的操作"></p>
<h4 id="读写string对象"><a href="#读写string对象" class="headerlink" title="读写string对象"></a>读写string对象</h4><p>可以使用IO操作符读写string对象。</p>
<p>在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。如果程序只定义一个string对象，而输入的是“ <strong>Hello world!</strong> ”,则输出将是“<strong>Hello</strong>”，输出结果没有任何空格。如果定义两个string对象，并且连续输入输出，则输出则是“<strong>HelloWorld</strong>”。</p>
<h4 id="读取未知数量的string对象"><a href="#读取未知数量的string对象" class="headerlink" title="读取未知数量的string对象"></a>读取未知数量的string对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string word;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;word)</span><br><span class="line">		cout&lt;&lt;word&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用getline读取一整行"><a href="#使用getline读取一整行" class="headerlink" title="使用getline读取一整行"></a>使用getline读取一整行</h4><p>有时我们希望在最终得到的字符串中保留输入时的空白符，这时应该用<strong>getline</strong>函数代替原来的&gt;&gt;运算符。</p>
<p>getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。</p>
<h4 id="string的empty和size操作"><a href="#string的empty和size操作" class="headerlink" title="string的empty和size操作"></a>string的empty和size操作</h4><p><strong>empty</strong>函数根据string对象是否为空返回一个对应的布尔值。</p>
<p>empty函数是string的一个成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只输出非空的行</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin,line))</span><br><span class="line"><span class="keyword">if</span>(!line.<span class="built_in">empty</span>())<span class="comment">//逻辑非运算符(!)</span></span><br><span class="line">	cout&lt;&lt;line&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p><strong>size</strong>函数返回string对象的长度</p>
<h4 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string::size_type类型"></a>string::size_type类型</h4><p>size函数返回的是一个string::size_type类型的值。</p>
<p>string类及其他大多数标准库类型都定义了几种配套的类型，如<strong>size_type</strong>。</p>
<p>所有用于存放string类的size函数返回值的变量，都应该是string::size_type类型的。</p>
<p>假设n是一个具有负值的int，则表达式s.size()&lt;n的判断结果几乎肯定是true，这是因为负值n会自动地转换成一个比较大的无符号值。</p>
<p>==注：如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。==</p>
<h4 id="比较string对象"><a href="#比较string对象" class="headerlink" title="比较string对象"></a>比较string对象</h4><p>string对象的比较依照（大小写敏感）字典顺序：<br><strong>1</strong>.如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。<br><strong>2</strong>.如果两个string对象再某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string phrase=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">string slang=<span class="string">&quot;Hiya&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>根据规则1可判断，对象str小于对象phrase；根据规则2可判断，对象slang既大于str也大于phrase。</p>
<h4 id="为string对象赋值"><a href="#为string对象赋值" class="headerlink" title="为string对象赋值"></a>为string对象赋值</h4><p>对于string类而言，允许把一个对象的值赋给另外一个对象。</p>
<h4 id="两个string对象相加"><a href="#两个string对象相加" class="headerlink" title="两个string对象相加"></a>两个string对象相加</h4><p>两个string对象相加得到一个新的string对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。</p>
<h4 id="字面值和string对象相加"><a href="#字面值和string对象相加" class="headerlink" title="字面值和string对象相加"></a>字面值和string对象相加</h4><p>因为标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1=<span class="string">&quot;hello&quot;</span>,s2=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">string s4=s1+<span class="string">&quot;,&quot;</span>+s2+<span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s4=s1+<span class="string">&quot;,&quot;</span>;			<span class="comment">//正确</span></span><br><span class="line">string s5=<span class="string">&quot;hello&quot;</span>+<span class="string">&quot;,&quot;</span>;		<span class="comment">//错误，两个运算对象都不是string</span></span><br><span class="line">string s6=s1+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;world&quot;</span>;	<span class="comment">//正确，等于string s6=(s1+&quot;,&quot;)+&quot;world&quot;</span></span><br><span class="line">string s7=<span class="string">&quot;hello&quot;</span>+<span class="string">&quot;,&quot;</span>+s2;	<span class="comment">//错误，等于string s7=(hello+&quot;,&quot;)+s2,不能把字面值直接相加</span></span><br></pre></td></tr></table></figure>
<p>==注：字符串字面值与string是不同的类型==</p>
<h3 id="3-2-3-处理string对象中的字符"><a href="#3-2-3-处理string对象中的字符" class="headerlink" title="3.2.3 处理string对象中的字符"></a>3.2.3 处理string对象中的字符</h3><p><img src="https://img-blog.csdnimg.cn/20210420224751112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70" alt="cctype头文件中的函数"></p>
<blockquote>
<p><strong>建议:使用C++版本的C标准库头文件</strong><br>如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些优势C++语言所独有的</p>
</blockquote>
<h4 id="处理每个字符？使用基于范围的for语句"><a href="#处理每个字符？使用基于范围的for语句" class="headerlink" title="处理每个字符？使用基于范围的for语句"></a>处理每个字符？使用基于范围的for语句</h4><p>如果想对string对象中的每个字符做点什么操作，目前最好的办法是使用C++11新标准提供的一种语句：<strong>范围for（range for）</strong>语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：</p>
<blockquote>
<p>for(declaration：expression)<br>        statement</p>
</blockquote>
<p>其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化expression部分的下一个元素值。</p>
<p>我们可以使用范围for语句把string对象中的字符每行一个输出出来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//每行输出str中的一个字符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:str)		<span class="comment">//对于str中的每个字符</span></span><br><span class="line">	cout&lt;&lt;c&lt;&lt;endl;	<span class="comment">//输出当前字符，后面紧跟一个换行符</span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用范围for语句和ispunct函数来统计string对象中标点符号的个数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">stirng <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//punct_cnt的类型和s.size的返回类型一样</span></span><br><span class="line"><span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) punct_cnt=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//统计s中标点符号的数量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">ispunct</span>(c))</span><br><span class="line">		++punct_cnt;</span><br><span class="line">cout&lt;&lt;punct_cnt;</span><br><span class="line">	&lt;&lt;<span class="string">&quot; punctuation characters in &quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h4 id="使用范围for语句改变字符串中的字符"><a href="#使用范围for语句改变字符串中的字符" class="headerlink" title="使用范围for语句改变字符串中的字符"></a>使用范围for语句改变字符串中的字符</h4><p>如果想要改变string对象中字符的值，必须把循环变量定义成引用类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把字符串改写为大写字母的形式</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello world!!!&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(<span class="keyword">auto</span> &amp;c:s)</span></span></span><br><span class="line"><span class="function">	c</span>=<span class="built_in">toupper</span>(c);</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h4 id="只处理一部分字符？"><a href="#只处理一部分字符？" class="headerlink" title="只处理一部分字符？"></a>只处理一部分字符？</h4><p>要想访问string对象中的单个字符有两种形式：一种是使用下标，另外一种是使用迭代器。</p>
<p><strong>下标运算符</strong>（**[ ]**）接收的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置，返回值是该位置上字符的引用。</p>
<p>string对象的下标从0开始，s[s.size()-1]是最后一个字符。</p>
<p>下标的值称为“下标”或者“索引”，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带符号类型的值将自动转换为string::size_type表达的无符号类型。</p>
<p>只要字符串不是常量，就能为下标运算符返回的字符赋新值。</p>
<h4 id="使用下标进行迭代"><a href="#使用下标进行迭代" class="headerlink" title="使用下标进行迭代"></a>使用下标进行迭代</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把s的第一个词改成大写形式</span></span><br><span class="line"><span class="comment">//依次处理s中的字符直至我们处理完全部字符或者遇到一个空白</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">decltype</span>(s.<span class="built_in">size</span>())) index=<span class="number">0</span>;</span><br><span class="line">	index!=s.<span class="built_in">size</span>()&amp;&amp;!<span class="built_in">isspace</span>(s[index]);++index)</span><br><span class="line">		s[index]=<span class="built_in">toupper</span>(s[index]);</span><br></pre></td></tr></table></figure>
<h4 id="使用下标执行随机访问"><a href="#使用下标执行随机访问" class="headerlink" title="使用下标执行随机访问"></a>使用下标执行随机访问</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把0到15之间的十进制数转换成对应的十六进制形式</span></span><br><span class="line"><span class="keyword">const</span> string hexdigits=<span class="string">&quot;0123456789ABCDEF&quot;</span>;<span class="comment">//可能的十六进制数字</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Enter a series of numbers between 0 and 15&quot;</span>;</span><br><span class="line">	&lt;&lt;<span class="string">&quot; separated by spaces. Hit ENTER when finished:&quot;</span></span><br><span class="line">	&lt;&lt;endl;</span><br><span class="line">string result;</span><br><span class="line">string::size_type n;				<span class="comment">//用于保存从输入流读取的数</span></span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">	<span class="keyword">if</span>(n&lt;hexdigits.<span class="built_in">size</span>())			<span class="comment">//忽略无效输入</span></span><br><span class="line">			rusult+=hexdigits[n];	<span class="comment">//得到对应十六进制数字</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Your hex number is: &quot;</span>&lt;&lt;result&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h2><p>标准库类型<strong>Vector</strong>表示对象的集合，其中所有对象的类型都相同。因为Vector容纳着其他对象，所以它也常被称作<strong>容器（container）</strong>。</p>
<p>C++语言既有<strong>类模板（class template）</strong>，也有函数模板，其中vector是一个类模板。编译器根据模板创建类或函数的过程称为<strong>实例化（instantiation）</strong>，当使用模板时，需要指出编译器把类或函数实例化成何种类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec;				<span class="comment">//ivec保存int类型的对象</span></span><br><span class="line">vector&lt;Sales_item&gt; Sales_vec;	<span class="comment">//保存Sales_item类型的对象</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; file;	<span class="comment">//该向量的元素是vector对象</span></span><br></pre></td></tr></table></figure>
<p>==注：vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector&lt; int &gt;。==</p>
<p>不保存包含引用的vector。</p>
<h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><p>和任何一种类类型一样，vector模板控制着定义和初始化向量的方法。<br><img src="https://img-blog.csdnimg.cn/20210427153137154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70" alt="初始化vector对象的方法"><br>可以默认初始化vector对象，从而创建一个指定类型的空vector：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;<span class="comment">//默认初始化，svec不含任何元素</span></span><br></pre></td></tr></table></figure>
<p>往vector对象中添加元素最常见的方式是先定义一个空vector，然后当运行时获取元素的值后再逐一添加。</p>
<p>也可以在定义vector对象时指定元素的初始值，例如，允许把一个vector对象的元素拷贝给另外一个vector对象，注意两个vector对象的类型必须相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec;			<span class="comment">//初始状态为空</span></span><br><span class="line"><span class="comment">//在此处给ivec添加一些值</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec2</span><span class="params">(ivec)</span></span>;	<span class="comment">//把ivec的元素拷贝给ivec2</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec3 = ivec;	<span class="comment">//把ivec的元素拷贝给ivec3</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(ivec2)</span></span>;	<span class="comment">//错误：svec的元素是string对象，不是int</span></span><br></pre></td></tr></table></figure>
<h4 id="列表初始化vector对象"><a href="#列表初始化vector对象" class="headerlink" title="列表初始化vector对象"></a>列表初始化vector对象</h4><p>C++11新标准还提供了另外一种为vector对象的元素赋初值的方法，即列表初始化。此时，用花括号括起来的0个或多个初始元素值被赋给vector对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; articles=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="创建指定数量的元素"><a href="#创建指定数量的元素" class="headerlink" title="创建指定数量的元素"></a>创建指定数量的元素</h4><p>还可以用vector对象容纳的元素数量和所有元素的统一初始值来初始化vector对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>,<span class="number">-1</span>)</span></span>;		<span class="comment">//10个int类型的元素，每个都被初始化为-1</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>,<span class="string">&quot;hi!&quot;</span>)</span></span>;	<span class="comment">//10个string类型的元素，每个数都被初始化为&quot;hi!&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a>值初始化</h4><p>通常情况下，可以只提供vector对象容纳的元素数量而不用略去初始值，此时库会创建一个 <strong>值初始化的（value-initialized）</strong> 元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>;		<span class="comment">//10个元素，每个都初始化为0</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//10个元素，每个都是空string对象</span></span><br></pre></td></tr></table></figure>
<p>对这种初始化的方法由两个特殊限制：其一，有些类要求必须明确地提供初始值，如果vector对象中元素地类型不支持默认初始化，我们就必须提供初始地元素值。其二，如果只提供了元素地数量而没有设定初始值，只能使用直接初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi=<span class="number">10</span>;<span class="comment">//错误：必须使用直接初始化的形式指定向量大小</span></span><br></pre></td></tr></table></figure>
<h4 id="列表初始值还是元素数量？"><a href="#列表初始值还是元素数量？" class="headerlink" title="列表初始值还是元素数量？"></a>列表初始值还是元素数量？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;		<span class="comment">//v1有10个元素，每个的值都是0</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;		<span class="comment">//v2有1个元素，该元素的值是10</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>;	<span class="comment">//v3有10个元素，每个的值是1</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">10</span>,<span class="number">1</span>&#125;;	<span class="comment">//v4有2个元素，值分别是10和1</span></span><br></pre></td></tr></table></figure>
<p>如果用的是圆括号，可以说提供的值是用来构造（construct）vector对象的。如果用的是花括号，可以表述成我们像列表初始化（list initialize）该vector对象。</p>
<h3 id="3-3-2-向vector对象中添加元素"><a href="#3-3-2-向vector对象中添加元素" class="headerlink" title="3.3.2 向vector对象中添加元素"></a>3.3.2 向vector对象中添加元素</h3><p>对vector对象来说，直接初始化的方式适用于三种情况：初始值已知且数量很少，初始值是另一个vector对象的副本、所有元素的初始值都一样。</p>
<p>然而更常见的情况是：创建一个vector对象时并不清楚实际所需的元素个数，元素的值也无法确定。还有即使元素的初值已知，但如果这些值总量较大而各不相同，那么在创建vector对象的时候执行初始化操作也会显得过于烦琐。</p>
<p>这时候经常要利用<strong>push_back</strong>函数向其中添加元素。push_back负责把一个值当成vector对象的尾元素“<strong>压倒（push）</strong>”vector对象的“<strong>尾端（back）</strong>”。</p>
<blockquote>
<p><strong>关键概念：vector对象能高效增长</strong><br>C++标准要求vector应该能在运行时高效快速地添加元素。除非所有元素地值都一样，否则更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。</p>
</blockquote>
<h4 id="向vector对象添加元素蕴含的编程假定"><a href="#向vector对象添加元素蕴含的编程假定" class="headerlink" title="向vector对象添加元素蕴含的编程假定"></a>向vector对象添加元素蕴含的编程假定</h4><p>必须要确保缩写的循环正确无误，特别是在循环有可能改变vector对象容量的时候。</p>
<p>如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。<br>==注：范围for语句体内不应改变其所遍历序列的大小。==</p>
<h3 id="3-3-3-其他vector操作"><a href="#3-3-3-其他vector操作" class="headerlink" title="3.3.3 其他vector操作"></a>3.3.3 其他vector操作</h3><p><img src="https://img-blog.csdnimg.cn/20210506194923981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70" alt="vector支持的操作"><br>访问vector对象中元素的方法和访问string对象中字符的方法差不多，也是通过元素在vector对象中的位置。例如，可以使用范围for语句处理vector对象中的所有元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : v)	<span class="comment">//对于v中的每个元素（注意，i是一个引用）</span></span><br><span class="line">	i *=i;			<span class="comment">//求元素值的平方</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : v)		<span class="comment">//对于v中的每个元素</span></span><br><span class="line">	cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;	<span class="comment">//输出该元素</span></span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>==注：要使用size_type，需首先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型：如vector<int>::size_type是正确的，而vector::size_type是错误的。==</p>
<p>各个相等性运算符和关系运算符也与string的相应运算符功能一致。</p>
<p>只有当元素的值可比较时，vector对象才能被比较。</p>
<h4 id="计算vector内对象的索引"><a href="#计算vector内对象的索引" class="headerlink" title="计算vector内对象的索引"></a>计算vector内对象的索引</h4><p>使用下标运算符能获取到指定的元素。</p>
<h4 id="不能用下标形式添加元素"><a href="#不能用下标形式添加元素" class="headerlink" title="不能用下标形式添加元素"></a>不能用下标形式添加元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec;<span class="comment">//空vector对象</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">decltype</span>(ivec.<span class="built_in">size</span>()) ix=<span class="number">0</span>;ix != <span class="number">10</span>;++ix)</span><br><span class="line">&#123;</span><br><span class="line">	ivec[ix]=ix;<span class="comment">//严重错误:ivec不包含任何元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==注：vector对象（以及string对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。==</p>
<blockquote>
<p><strong>提示：只能对确知已存在的元素执行下标操作！</strong><br><code>vecotr&lt;int&gt; ivec;</code><br><code>cout&lt;&lt;ivec[0]//错误</code><br><code>vector&lt;int&gt;ivec2(10);</code><br><code>cout&lt;&lt;ivec[10];//错误</code><br>试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。这种错误会产生很严重的后果如<strong>缓冲区溢出（buffer overflow）</strong>。<br>确保下标合法的一种有效手段就是尽可能使用范围for语句。</p>
</blockquote>
<hr>
<h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h2><p>我们已经直到可以使用下标运算符来访问string对象的字符或vector对象的元素，还有另外一种更通用的机制也可以实现同样的目的，这就是<strong>迭代器（iterator）</strong>。所有标准库容器都可以使用迭代器。</p>
<p>类似于指针类型，迭代器也提供了对对象的间接访问。</p>
<h3 id="3-4-1-使用迭代器"><a href="#3-4-1-使用迭代器" class="headerlink" title="3.4.1 使用迭代器"></a>3.4.1 使用迭代器</h3><p>获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。</p>
<p>比如，这些类型都拥有名为<strong>begin</strong>和<strong>end</strong>成员，其中begin成员负责返回指向第一个元素的迭代器，end成员则负责返回指向容器“<strong>尾元素的下一位置（one past the end）</strong>”，也就是说，该迭代器指示的是容器的一个本不存在的“<strong>尾后（off the end）</strong>”元素。end成员返回的迭代器常被称为<strong>尾后迭代器（off-the-end iterator）</strong> 或者 <strong>尾迭代器（end iterator）</strong>。</p>
<p>如果容器为空，则begin和end返回的是同一个迭代器。，即尾后迭代器。</p>
<p>一般来说，我们不在意迭代器准确的类型到底是什么，因此我们使用auto关键字定义变量来存放迭代器。</p>
<h4 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a>迭代器运算符</h4><p><img src="https://img-blog.csdnimg.cn/20210506202538967.png" alt="标准容器迭代器的运算符"><br>和指针类似，也能通过解引用迭代器来获取它所指示的元素，执行解引用的迭代器必须合法并确实指示着某个元素，试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">begin</span>()!=s.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> it=s.<span class="built_in">begin</span>();</span><br><span class="line">	*it =<span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><strong>Some string</strong></p>
<h4 id="将迭代器从一个元素移动到另外一个元素"><a href="#将迭代器从一个元素移动到另外一个元素" class="headerlink" title="将迭代器从一个元素移动到另外一个元素"></a>将迭代器从一个元素移动到另外一个元素</h4><p>迭代器使用递增运算符来从一个元素移动到下一个元素，使用递减运算符来从一个元素移动到上一个元素。</p>
<blockquote>
<p><strong>关键概念：泛型编程</strong><br>所有标准库容器的迭代器都定义了==和!=，但是它们中的大多数都没有定义&lt;运算符，因此，只要我们养成使用迭代器和!=的习惯，就不用太在意用的是哪种容器类型。</p>
</blockquote>
<h4 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h4><p>那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it;		<span class="comment">//it能读写vector&lt;int&gt;的元素</span></span><br><span class="line">string::iterator it2;			<span class="comment">//it2能读写string对象中的字符</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::const_iterator it3;<span class="comment">//it3只能读元素，不能写元素</span></span><br><span class="line">string::const_iterator it4;		<span class="comment">//it4只能读字符，不能写字符</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>术语：迭代器和迭代器类型</strong><br>迭代器这个名词有三种不同的含义：可能是迭代器概念本省，也可能是指容器定义的迭代器类型，还可能是指某个迭代器对象。<br>重点是理解在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它支持一套操作，这套操作使得我们能访问容器的元素或者从某个元素移动到另外一个元素。<br>每个容器类定义了一个名为iterator的类型，该类型支持迭代器概念所规定的一套操作。</p>
</blockquote>
<h4 id="begin和end运算符"><a href="#begin和end运算符" class="headerlink" title="begin和end运算符"></a>begin和end运算符</h4><p>begin和end返回的具体类型由对象是否是常量决定，如果是常量，返回const_iterator，反之返回iterator。</p>
<p>为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是cbegin和cend：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it3=v.<span class="built_in">cbegin</span>();<span class="comment">//it3的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>
<h4 id="结合解引用和成员访问操作"><a href="#结合解引用和成员访问操作" class="headerlink" title="结合解引用和成员访问操作"></a>结合解引用和成员访问操作</h4><p>解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*it).<span class="built_in">empty</span>();<span class="comment">//解引用it，然后调用结果对象的empty成员</span></span><br><span class="line">*it.<span class="built_in">empty</span>();<span class="comment">//错误：试图访问it的名为empty成员，但it是个迭代器，没有empty成员。</span></span><br></pre></td></tr></table></figure>
<p>为了简化上述表达式，C++语言定义了<strong>箭头运算符</strong>（**-&gt;**）。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说it-&gt;men和(*it).men的意思相同。<br>==注：谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。==</p>
<h4 id="3-4-2-迭代器运算"><a href="#3-4-2-迭代器运算" class="headerlink" title="3.4.2 迭代器运算"></a>3.4.2 迭代器运算</h4><p>所有的标准库容器都有支持递增运算的迭代器，类似的，也能用==和!=对任意标准库类型的两个有效迭代器进行比较。所有这些运算符被称为<strong>迭代器运算（iterator arithmetic）</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/2021050620474739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70" alt="vector和string迭代器支持的运算"></p>
<h4 id="迭代器的算术运算"><a href="#迭代器的算术运算" class="headerlink" title="迭代器的算术运算"></a>迭代器的算术运算</h4><p>可以令迭代器和一个整数值相加（或相减），其返回值是向前（或向后）移动了若干个位置的迭代器。</p>
<p>只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一个位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。</p>
<h4 id="使用迭代器运算"><a href="#使用迭代器运算" class="headerlink" title="使用迭代器运算"></a>使用迭代器运算</h4><p>使用迭代器运算的一个经典算法是二分搜索。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//text必须是有序的</span></span><br><span class="line"><span class="comment">//beg和end表示我们搜索的范围</span></span><br><span class="line"><span class="keyword">auto</span> beg=text.<span class="built_in">begin</span>(),end=text.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid=text.<span class="built_in">begin</span>()+(end-beg)/<span class="number">2</span>;<span class="comment">//初始状态下的中间点</span></span><br><span class="line"><span class="comment">//当还有元素尚未检查并且我们还没有找到sought时执行循环</span></span><br><span class="line"><span class="keyword">while</span>(mid!=end&amp;&amp;*mid!=sought)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(sought&lt;*mid)			<span class="comment">//我们要找的元素在前半部分吗？</span></span><br><span class="line">		end=mid;			<span class="comment">//如果是，调整搜索范围使得忽略掉后半部分</span></span><br><span class="line">	<span class="keyword">else</span>					<span class="comment">//我们要找的元素在后半部分吗？</span></span><br><span class="line">		beg=mid+<span class="number">1</span>;			<span class="comment">//在mid之后寻找</span></span><br><span class="line">	mid=beg+(end-beg)/<span class="number">2</span>;	<span class="comment">//新的中间点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><p>数组是一种类似于标准库类型vector的数据结构，与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问，不同的是，数组的大小确定不变，不能随意向数组中增加元素。<br>==注：如果不清楚元素的确切个数，请使用vector。==</p>
<h3 id="3-5-1-定义和初始化内置数组"><a href="#3-5-1-定义和初始化内置数组" class="headerlink" title="3.5.1 定义和初始化内置数组"></a>3.5.1 定义和初始化内置数组</h3><p>数组是一种复合类型。数组的声明形如a[d],其中a是数组的名字，d是数字的维度。维度说明了数组中元素的个数，因此必须大于0。维度必须是一个常量表达式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;<span class="comment">//不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>;<span class="comment">//常量表达式</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];<span class="comment">//含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *parr[sz];<span class="comment">//含有42个整形指针的数组</span></span><br><span class="line">string bad[cnt];<span class="comment">//错误：cnt不是常量表达式</span></span><br><span class="line">string strs[<span class="built_in">get_size</span>()];<span class="comment">//当get_size是constexpr时正确；否则错误</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，数组的元素被默认初始化。</p>
<p>==和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。==</p>
<p>定义数组的时候必须指定数组的类型，不允许用auto关键字推断类型。不存在引用的数组。</p>
<h4 id="显式初始化数组元素"><a href="#显式初始化数组元素" class="headerlink" title="显式初始化数组元素"></a>显式初始化数组元素</h4><p>可以对数组的元素进行列表初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ial[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;		<span class="comment">//含有3个元素的数组，元素值分别是0，1，2</span></span><br><span class="line"><span class="keyword">int</span> a2[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;			<span class="comment">//维度是3的数组</span></span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;			<span class="comment">//等价于a3[]=&#123;0，1，2，0，0&#125;</span></span><br><span class="line">string a4[<span class="number">3</span>]=&#123;<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span>&#125;;	<span class="comment">//等价于a4[]=&#123;&quot;hi&quot;,&quot;bye&quot;,&quot;&quot;&#125;</span></span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;			<span class="comment">//错误：初始值过多</span></span><br></pre></td></tr></table></figure>
<h4 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a>字符数组的特殊性</h4><p>字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化，一定要注意字符串字面值的结尾处还有一个空字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[]=&#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;;		<span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"><span class="keyword">char</span> a2[]=&#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;	<span class="comment">//列表初始化，含有显式的空字符</span></span><br><span class="line"><span class="keyword">char</span> a3[]=<span class="string">&quot;C++&quot;</span>;				<span class="comment">//自动添加表示字符串结束的空字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>]=<span class="string">&quot;Daniel&quot;</span>;		<span class="comment">//错误：没有空间可存放空字符</span></span><br></pre></td></tr></table></figure>
<h4 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h4><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。<br>==注：一些编译器支持数组的赋值，这就是所谓的<strong>编译器拓展（compiler extension）</strong>。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常运行。==</p>
<h4 id="理解复杂的数组声明"><a href="#理解复杂的数组声明" class="headerlink" title="理解复杂的数组声明"></a>理解复杂的数组声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];			<span class="comment">//ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]=<span class="comment">/*?*/</span>;	<span class="comment">//错误：不存在引用的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*Parray)[<span class="number">10</span>]=&amp;arr;	<span class="comment">//Parray指向一个含有一个10个整数的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (&amp;arrRef)[<span class="number">10</span>]=arr;	<span class="comment">//arrRef引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，类型修饰符从右向左依次绑定，理解时最好用由内向外的顺序。</p>
<h3 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a>3.5.2 访问数组元素</h3><p>数组的元素也能使用范围for语句或下标运算符来访问。数组的索引从0开始。</p>
<p>在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版本。</p>
<p>数组除了大小固定这一特点外，其他用法与vector基本类似。</p>
<p>与vector和string一样，当需要遍历数组的所有元素时，最好的办法也是使用范围for语句。</p>
<h4 id="检查下标的值"><a href="#检查下标的值" class="headerlink" title="检查下标的值"></a>检查下标的值</h4><p>数组的下标是否在合理范围之内由程序员负责检查，所谓合理就是说下标应该大于等于0而且小于数组的大小。</p>
<h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3><p>使用数组的时候编译器一般会把它转换成指针。</p>
<p>对数组的元素使用取地址符就能得到指向该元素的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string nums[]=&#123;<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>&#125;;	<span class="comment">//数组的元素是string对象</span></span><br><span class="line">string *p=&amp;num[<span class="number">0</span>];						<span class="comment">//p指向nums的第一个元素</span></span><br></pre></td></tr></table></figure>
<p>数组还有一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string *p2 = nums;<span class="comment">//等价于p2 = &amp;nums[0];</span></span><br></pre></td></tr></table></figure>
<p>==注：在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。==</p>
<p>当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组，而当使用decltype关键字时，其返回的类型是数组而非指针。</p>
<h4 id="指针也是迭代器"><a href="#指针也是迭代器" class="headerlink" title="指针也是迭代器"></a>指针也是迭代器</h4><p>vector和string的迭代器支持的运算，数组的指针也全部支持。</p>
<h4 id="标准库函数begin和end"><a href="#标准库函数begin和end" class="headerlink" title="标准库函数begin和end"></a>标准库函数begin和end</h4><p>C++11新标准引入了两个名为begin和end的函数，这两个函数与容器中的两个同名成员功能类似。这两个函数定义在iterator头文件中。</p>
<h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>指向数组元素的指针可以执行所有迭代器的运算，这些运算用在指针和用在迭代器上意义完全一样。</p>
<p>和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素。</p>
<p>两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型。</p>
<p>只要两个指针指向同一个数组的元素，或者指向该数组的尾元素的下一位置，就能利用关系运算符对其进行比较。如果两个指针分别指向不相关的对象，则不能比较它们。</p>
<h4 id="解引用和指针运算的交互"><a href="#解引用和指针运算的交互" class="headerlink" title="解引用和指针运算的交互"></a>解引用和指针运算的交互</h4><p>指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针。最好在必要的地方加上圆括号。</p>
<h4 id="下标和指针"><a href="#下标和指针" class="headerlink" title="下标和指针"></a>下标和指针</h4><p>在很多情况下使用数组的名字其实用的是一个指向数组首元素的指针。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。内置的下标运算符可以处理负值，结果地址必须指向原来的指针所指同一数组中的元素（或是同一数组尾元素的下一位置）。</p>
<h3 id="3-5-4-C风格字符串"><a href="#3-5-4-C风格字符串" class="headerlink" title="3.5.4 C风格字符串"></a>3.5.4 C风格字符串</h3><p>==注：尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们。这是因为C风格字符串不仅用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。==<br>字符串字面值是一种通用结构的实例，这种结构即是C++由C继承而来的<strong>C风格字符串（C-style character string）</strong>。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以<strong>空字符结束（null terminated）</strong>。</p>
<h4 id="C标准库String函数"><a href="#C标准库String函数" class="headerlink" title="C标准库String函数"></a>C标准库String函数</h4><p>下标这些函数可用于操作C风格字符串，它们定义在cstring头文件中，cstring是C语言头文件string.h的C++版本。<br><img src="https://img-blog.csdnimg.cn/20210508101206356.png" alt="C风格字符串的函数"><br>传入此类函数的指针必须指向以空字符作为结束的数组。</p>
<h4 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h4><p>比较两个C风格字符串的方法和之前学习过的比较标准库string对象的方法大相径庭。比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;A string exanmple&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;A different string&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(s1&lt;s2) 	<span class="comment">//false:s2小于s1</span></span><br></pre></td></tr></table></figure>
<p>如果把这些运算符用在两个C风格字符串上，实际比较的将是指针而非字符串本身：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = <span class="string">&quot;A string example&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = <span class="string">&quot;A different string&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(ca1&lt;ca2)		<span class="comment">//未定义的:试图比较两个无关地址</span></span><br></pre></td></tr></table></figure>
<p>要想比较两个C风格字符串需要调用strcmp函数，此时比较的就不再是指针了。如果两个字符串相等，strcmp返回0;如果前面的字符串较大，返回正值；如果后面的字符串较大，返回负值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(ca1,ca2)&lt;<span class="number">0</span>)<span class="comment">//和两个string对象的比较s1&lt;s2效果一样</span></span><br></pre></td></tr></table></figure>
<h4 id="目标字符串的大小由调用者指定"><a href="#目标字符串的大小由调用者指定" class="headerlink" title="目标字符串的大小由调用者指定"></a>目标字符串的大小由调用者指定</h4><p>连接或拷贝C风格字符串也与标准库string对象的同类操作差别很大。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将largeStr初始化成s1、一个空格和s2的连接</span></span><br><span class="line">string lagerStr = s1+<span class="string">&quot; &quot;</span>+s2;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果我们计算错了largeStr的大小将引发严重错误</span></span><br><span class="line"><span class="built_in">strcpy</span>(largeStr,ca1);	<span class="comment">//把ca1拷贝给largeStr</span></span><br><span class="line"><span class="built_in">strcat</span>(largeStr,<span class="string">&quot; &quot;</span>);	<span class="comment">//在largeStr的末尾加上一个空格</span></span><br><span class="line"><span class="built_in">strcat</span>(largeStr,ca2);	<span class="comment">//把ca2连接到largeStr后面</span></span><br></pre></td></tr></table></figure>
<p>一个潜在的问题是，我们在估算largeStr后需的空间时不容易估准，而且largeStr所存的内容一旦改变，就必须重新检查其空间是否足够。<br>==注：对大多数应用来说，使用标准库string要比使用C风格字符串更安全、更高效。==</p>
<h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h3><p>任何出现字符串字面值的地方都可以用空字符结束的字符数组来替代：<br><strong>·</strong> 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。<br><strong>·</strong> 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）;在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。</p>
<p>上述性质反过来就不成立了。</p>
<p>如果程序的某处需要一个C风格字符串，无法直接用string对象来代替它。例如，不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = s;				<span class="comment">//错误:不能用string对象初始化char*</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = s.<span class="built_in">c_str</span>()	<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p>c_str函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个string对象的一样。结果指针的类型是const char*，从而确保我们不会改变字符数组的内容。<br>==注：如果执行玩c_str()函数后程序像一只都能使用其返回的数组，最好将该数组重新拷贝一份。==</p>
<h4 id="使用数组初始化vector对象"><a href="#使用数组初始化vector对象" class="headerlink" title="使用数组初始化vector对象"></a>使用数组初始化vector对象</h4><p>允许数组来初始化vector对象。要实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//ivec有6个元素，分别是int_arr中对应元素的副本</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr),end(int_arr))</span></span>;</span><br></pre></td></tr></table></figure>
<p>用于初始化vector对象的值也可能仅是数组的一部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝三个元素，int_arr[1],int_arr[2],int_arr[3]</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">subVec</span><span class="params">(int_arr+<span class="number">1</span>,int_arr+<span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>建议：尽量使用标准库类型而非数组</strong><br>使用指针和数组很容易出错。一部分原因是概念上的问题：指针常用于底层操作，因此容易引发一些与繁琐细节有关的错误。其他问题则源于语法错误，特别是声明指针时的语法错误。<br>现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。</p>
</blockquote>
<hr>
<h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2><p>严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。</p>
<p>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];<span class="comment">//大小为3的数组，每个元素是含有4个整数的数组</span></span><br><span class="line"><span class="comment">//大小为10的数组，它的每个元素都是大小为20的数组</span></span><br><span class="line"><span class="comment">//这些数组的元素是含有30个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//将所有元素初始化为0</span></span><br></pre></td></tr></table></figure>
<p>对于二维数组来说，常把第一个维度称作行，第二个维度称作列。</p>
<h4 id="多维数组的初始化"><a href="#多维数组的初始化" class="headerlink" title="多维数组的初始化"></a>多维数组的初始化</h4><p>允许使用花括号括起来的一组值初始化多维数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">		&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有标识每行的花括号，与之前的初始化语句等价的</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式地初始化每行地首元素</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式地初始化第一行，其他元素执行值初始化</span></span><br><span class="line"><span class="keyword">int</span> ix[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="多维数组地下标引用"><a href="#多维数组地下标引用" class="headerlink" title="多维数组地下标引用"></a>多维数组地下标引用</h4><p>可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。</p>
<p>如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的数元素；反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用arr的首元素为ia的最后一行的最后一个元素赋值</span></span><br><span class="line">ia[<span class="number">2</span>][<span class="number">3</span>]=arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (&amp;row)[<span class="number">4</span>]=ia[<span class="number">1</span>];<span class="comment">//把row绑定到ia的第二个4元素数组上</span></span><br></pre></td></tr></table></figure>
<p>程序中经常会用到两层嵌套的for循环来处理多维数组的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> rowCnt = <span class="number">3</span>,colCnt = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> ia[rowCnt][colCnt];<span class="comment">//12个未初始化的元素</span></span><br><span class="line"><span class="comment">//对于每一行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i != rowCnt;++i)&#123;</span><br><span class="line">	<span class="comment">//对于行内的每一列</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>;j != colCnt;++j)&#123;</span><br><span class="line">	<span class="comment">//将元素的位置索引作为它的值</span></span><br><span class="line">	ia[i][j]= i* conCnt+j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用范围for语句处理多维数组"><a href="#使用范围for语句处理多维数组" class="headerlink" title="使用范围for语句处理多维数组"></a>使用范围for语句处理多维数组</h4><p>前一个程序可以简化为如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : ia)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col : row)&#123;</span><br><span class="line">		col=cnt;</span><br><span class="line">		++cnt;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做。举一个例子，考虑如下的循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;row : ia)	<span class="comment">//对于外层数组的每一个元素</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> col : row)		<span class="comment">//对于内层数组的每一个元素</span></span><br><span class="line">		cout&lt;&lt;col&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>这个循环并没有任何写操作，可是我们还是将外层循环的控制变量声明成了引用类型，这是为了避免数组被自动转成指针。假设不用引用类型，则循环如下述形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> row : ia)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> col : row)</span><br></pre></td></tr></table></figure>
<p>程序将无法通过编译。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转换成指向该数组内首元素的指针。这样得到的row的类型就是int<em>，显然内层的循环就不合法了，编译器将试图在一个int</em>内遍历，这显然和程序的初衷相去甚远。<br>==注：要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该时引用类型。==</p>
<h4 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h4><p>当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。<br>==注：定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。==<br>因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];		<span class="comment">//大小为3的数组，每个元素是含有4个整数的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">4</span>] = ia;	<span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];			<span class="comment">//p指向ia的尾元素</span></span><br></pre></td></tr></table></figure>
<p>==注：在上述声明中，圆括号必不可少。==</p>
<p>随着C++11新标准的提出，通过使用auto或者decltype就能尽可能地避免在数组前面加上一个指针类型。</p>
<p>当然，使用标准库函数begin和end也能实现同样的功能，而且看起来简洁一些。</p>
<h4 id="类型别名简化多维数组的指针"><a href="#类型别名简化多维数组的指针" class="headerlink" title="类型别名简化多维数组的指针"></a>类型别名简化多维数组的指针</h4><p>读、写和理解一个指向多维数组的指针是一个让人不胜其烦的工作，使用类型别名就能让这项工作变得简单一点，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_array = <span class="keyword">int</span>[<span class="number">4</span>];<span class="comment">//新标准下类型别名的声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_array[<span class="number">4</span>];<span class="comment">//等价的typedef声明</span></span><br><span class="line"><span class="comment">//输出ia中每个元素的值，每个内层数组各占一行</span></span><br><span class="line"><span class="keyword">for</span>(int_array *p = ia;p != ia + <span class="number">3</span>;++p)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> *q = *p;q != *p+<span class="number">4</span>;++q)</span><br><span class="line">		cout&lt;&lt;*q&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">天了噜Rex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/17/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/">http://example.com/2021/11/17/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/17/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">《C++Primer》学习笔记_第四章 表达式</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/17/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">《C++Primer》学习笔记_第二章 变量和基本类型.md</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">天了噜Rex</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">24</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Phantasm-of-Observer"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">第3章 字符串、向量和数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E"><span class="toc-number">2.</span> <span class="toc-text">3.1 命名空间的using声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E5%90%8D%E5%AD%97%E9%83%BD%E9%9C%80%E8%A6%81%E7%8B%AC%E7%AB%8B%E7%9A%84using%E5%A3%B0%E6%98%8E"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">每个名字都需要独立的using声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8D%E5%BA%94%E5%8C%85%E5%90%ABusing%E5%A3%B0%E6%98%8E"><span class="toc-number">2.0.0.2.</span> <span class="toc-text">头文件不应包含using声明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring"><span class="toc-number">2.1.</span> <span class="toc-text">3.2 标准库类型string</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96string%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.1.</span> <span class="toc-text">3.2.1 定义和初始化string对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">直接初始化和拷贝初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-string%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.2.</span> <span class="toc-text">3.2.2 string对象上的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99string%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">读写string对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%9C%AA%E7%9F%A5%E6%95%B0%E9%87%8F%E7%9A%84string%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">读取未知数量的string对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8getline%E8%AF%BB%E5%8F%96%E4%B8%80%E6%95%B4%E8%A1%8C"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">使用getline读取一整行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E7%9A%84empty%E5%92%8Csize%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">string的empty和size操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string-size-type%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">string::size_type类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83string%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.2.6.</span> <span class="toc-text">比较string对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BAstring%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC"><span class="toc-number">2.1.2.7.</span> <span class="toc-text">为string对象赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AAstring%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%8A%A0"><span class="toc-number">2.1.2.8.</span> <span class="toc-text">两个string对象相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%92%8Cstring%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%8A%A0"><span class="toc-number">2.1.2.9.</span> <span class="toc-text">字面值和string对象相加</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E5%A4%84%E7%90%86string%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.2.3 处理string对象中的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%AF%8F%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">处理每个字符？使用基于范围的for语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%E6%94%B9%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">使用范围for语句改变字符串中的字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E5%A4%84%E7%90%86%E4%B8%80%E9%83%A8%E5%88%86%E5%AD%97%E7%AC%A6%EF%BC%9F"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">只处理一部分字符？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8B%E6%A0%87%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">使用下标进行迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8B%E6%A0%87%E6%89%A7%E8%A1%8C%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">2.1.3.5.</span> <span class="toc-text">使用下标执行随机访问</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector"><span class="toc-number">2.2.</span> <span class="toc-text">3.3 标准库类型vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.1.</span> <span class="toc-text">3.3.1 定义和初始化vector对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">列表初始化vector对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">创建指定数量的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">值初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%80%BC%E8%BF%98%E6%98%AF%E5%85%83%E7%B4%A0%E6%95%B0%E9%87%8F%EF%BC%9F"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">列表初始值还是元素数量？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E5%90%91vector%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.2.</span> <span class="toc-text">3.3.2 向vector对象中添加元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91vector%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E8%95%B4%E5%90%AB%E7%9A%84%E7%BC%96%E7%A8%8B%E5%81%87%E5%AE%9A"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">向vector对象添加元素蕴含的编程假定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E5%85%B6%E4%BB%96vector%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.3.3 其他vector操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97vector%E5%86%85%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">计算vector内对象的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E7%94%A8%E4%B8%8B%E6%A0%87%E5%BD%A2%E5%BC%8F%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">不能用下标形式添加元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.3.</span> <span class="toc-text">3.4 迭代器介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.4.1 使用迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">迭代器运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">将迭代器从一个元素移动到另外一个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">迭代器类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#begin%E5%92%8Cend%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">begin和end运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.1.5.</span> <span class="toc-text">结合解引用和成员访问操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97"><span class="toc-number">2.3.1.6.</span> <span class="toc-text">3.4.2 迭代器运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-number">2.3.1.7.</span> <span class="toc-text">迭代器的算术运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%90%E7%AE%97"><span class="toc-number">2.3.1.8.</span> <span class="toc-text">使用迭代器运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.</span> <span class="toc-text">3.5 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.1.</span> <span class="toc-text">3.5.1 定义和初始化内置数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">显式初始化数组元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">字符数组的特殊性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">不允许拷贝和赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">理解复杂的数组声明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.4.2.</span> <span class="toc-text">3.5.2 访问数组元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%B8%8B%E6%A0%87%E7%9A%84%E5%80%BC"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">检查下标的值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.3.</span> <span class="toc-text">3.5.3 指针和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B9%9F%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">指针也是迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0begin%E5%92%8Cend"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">标准库函数begin和end</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">指针运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-number">2.4.3.4.</span> <span class="toc-text">解引用和指针运算的交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">2.4.3.5.</span> <span class="toc-text">下标和指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-C%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.4.4.</span> <span class="toc-text">3.5.4 C风格字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E6%A0%87%E5%87%86%E5%BA%93String%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">C标准库String函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%94%B1%E8%B0%83%E7%94%A8%E8%80%85%E6%8C%87%E5%AE%9A"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">目标字符串的大小由调用者指定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-5-%E4%B8%8E%E6%97%A7%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.5.</span> <span class="toc-text">3.5.5 与旧代码的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">使用数组初始化vector对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.5.</span> <span class="toc-text">3.6 多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.5.0.1.</span> <span class="toc-text">多维数组的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8"><span class="toc-number">2.5.0.2.</span> <span class="toc-text">多维数组地下标引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.5.0.3.</span> <span class="toc-text">使用范围for语句处理多维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.5.0.4.</span> <span class="toc-text">指针和多维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E7%AE%80%E5%8C%96%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.5.0.5.</span> <span class="toc-text">类型别名简化多维数组的指针</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/%5BSubstrate%20Recipes%E7%BF%BB%E8%AF%91%5D1.21%20Tightly-%20and%20Loosely-Coupled%20Pallets/" title="&lt;Substrate Recipes翻译&gt;1.21 Tightly- and Loosely-Coupled Pallets"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Substrate Recipes翻译&gt;1.21 Tightly- and Loosely-Coupled Pallets"/></a><div class="content"><a class="title" href="/2021/11/17/%5BSubstrate%20Recipes%E7%BF%BB%E8%AF%91%5D1.21%20Tightly-%20and%20Loosely-Coupled%20Pallets/" title="&lt;Substrate Recipes翻译&gt;1.21 Tightly- and Loosely-Coupled Pallets">&lt;Substrate Recipes翻译&gt;1.21 Tightly- and Loosely-Coupled Pallets</a><time datetime="2021-11-17T12:46:48.000Z" title="Created 2021-11-17 20:46:48">2021-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/%E3%80%8ARust%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%BE%85%E6%9B%B4%E6%96%B0/" title="《Rust权威指南》学习笔记_待更新"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Rust权威指南》学习笔记_待更新"/></a><div class="content"><a class="title" href="/2021/11/17/%E3%80%8ARust%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%BE%85%E6%9B%B4%E6%96%B0/" title="《Rust权威指南》学习笔记_待更新">《Rust权威指南》学习笔记_待更新</a><time datetime="2021-11-17T12:40:53.000Z" title="Created 2021-11-17 20:40:53">2021-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC11%E7%AB%A0%20%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/" title="《Python编程：从入门到实践》学习笔记_第11章 测试代码"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Python编程：从入门到实践》学习笔记_第11章 测试代码"/></a><div class="content"><a class="title" href="/2021/11/17/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC11%E7%AB%A0%20%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/" title="《Python编程：从入门到实践》学习笔记_第11章 测试代码">《Python编程：从入门到实践》学习笔记_第11章 测试代码</a><time datetime="2021-11-17T12:39:44.000Z" title="Created 2021-11-17 20:39:44">2021-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC10%E7%AB%A0%20%E6%96%87%E4%BB%B6%E5%92%8C%E5%BC%82%E5%B8%B8/" title="《Python编程：从入门到实践》学习笔记_第10章 文件和异常"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Python编程：从入门到实践》学习笔记_第10章 文件和异常"/></a><div class="content"><a class="title" href="/2021/11/17/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC10%E7%AB%A0%20%E6%96%87%E4%BB%B6%E5%92%8C%E5%BC%82%E5%B8%B8/" title="《Python编程：从入门到实践》学习笔记_第10章 文件和异常">《Python编程：从入门到实践》学习笔记_第10章 文件和异常</a><time datetime="2021-11-17T12:39:05.000Z" title="Created 2021-11-17 20:39:05">2021-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC9%E7%AB%A0%20%E7%B1%BB/" title="《Python编程：从入门到实践》学习笔记_第9章 类"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Python编程：从入门到实践》学习笔记_第9章 类"/></a><div class="content"><a class="title" href="/2021/11/17/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC9%E7%AB%A0%20%E7%B1%BB/" title="《Python编程：从入门到实践》学习笔记_第9章 类">《Python编程：从入门到实践》学习笔记_第9章 类</a><time datetime="2021-11-17T12:38:28.000Z" title="Created 2021-11-17 20:38:28">2021-11-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 天了噜Rex</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>