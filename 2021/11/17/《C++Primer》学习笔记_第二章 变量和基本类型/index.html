<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《C++Primer》学习笔记_第二章 变量和基本类型.md | 天了噜Rex的杂物堆</title><meta name="author" content="天了噜Rex"><meta name="copyright" content="天了噜Rex"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第二章 变量和基本类型———————————————————————————————————————————————————————— 2.1 基本内置类型C++定义了一套包括 算术类型（arithmetic） 和 空类型（void） 在内的基本数据类型。其中算术类型包含了字符，整数，布尔值，浮点数，空类型不对应相应的值。 2.1.1 算术类型算术类型分为两种：整型（integral，包括字符和布">
<meta property="og:type" content="article">
<meta property="og:title" content="《C++Primer》学习笔记_第二章 变量和基本类型.md">
<meta property="og:url" content="http://example.com/2021/11/17/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/index.html">
<meta property="og:site_name" content="天了噜Rex的杂物堆">
<meta property="og:description" content="第二章 变量和基本类型———————————————————————————————————————————————————————— 2.1 基本内置类型C++定义了一套包括 算术类型（arithmetic） 和 空类型（void） 在内的基本数据类型。其中算术类型包含了字符，整数，布尔值，浮点数，空类型不对应相应的值。 2.1.1 算术类型算术类型分为两种：整型（integral，包括字符和布">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-11-17T12:26:59.000Z">
<meta property="article:modified_time" content="2021-11-17T12:28:01.032Z">
<meta property="article:author" content="天了噜Rex">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/11/17/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《C++Primer》学习笔记_第二章 变量和基本类型.md',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-17 20:28:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">24</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">天了噜Rex的杂物堆</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《C++Primer》学习笔记_第二章 变量和基本类型.md</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-11-17T12:26:59.000Z" title="Created 2021-11-17 20:26:59">2021-11-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-11-17T12:28:01.032Z" title="Updated 2021-11-17 20:28:01">2021-11-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《C++Primer》学习笔记_第二章 变量和基本类型.md"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><p>————————————————————————————————————————————————————————</p>
<h2 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h2><p>C++定义了一套包括 <strong>算术类型（arithmetic）</strong> 和 <strong>空类型（void）</strong> 在内的基本数据类型。其中算术类型包含了字符，整数，布尔值，浮点数，空类型不对应相应的值。</p>
<h3 id="2-1-1-算术类型"><a href="#2-1-1-算术类型" class="headerlink" title="2.1.1 算术类型"></a>2.1.1 算术类型</h3><p>算术类型分为两种：<strong>整型</strong>（<strong>integral</strong>，包括字符和布尔值在内）和<strong>浮点型</strong>。<br><img src="https://img-blog.csdnimg.cn/20210315193807684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70" alt="算术类型"><br>基本字符类型是char，其他字符类型用于拓展字符集。</p>
<p>除字符和布尔类型之外，其他整型用来表示（可能）不同尺寸的整数。</p>
<p>浮点型可用来表示单精度、双精度和拓展精度值。<br>==注：执行浮点数计算最好选用double。在算术表达式中不要选用字符型或布尔型的值。==</p>
<h4 id="带符号类型和无符号类型"><a href="#带符号类型和无符号类型" class="headerlink" title="带符号类型和无符号类型"></a>带符号类型和无符号类型</h4><p>除去布尔型和拓展的字符型之外，其他整型可以划分为<strong>带符号的（signed）</strong> 和<strong>无符号的（unsigned）</strong> 两种，带符号的能表示正数、负数和0，无符号的只能表示大于0的数。</p>
<p>与其他整型不同，字符型被分为了三种：char、signed char和unsigned char。signed char和char并不完全一样，字符型有三种，字符的表现只有两种：有符号的和无符号的。类型char的实际表现由编译器来决定。</p>
<p>无符号类型中所有比特都用来存储值。例如，unsigned char可用来表示0-255之间的任一值。<br>==注：当明确知道数值不可能为负时，选用无符号类型==</p>
<h3 id="2-1-2-类型转换"><a href="#2-1-2-类型转换" class="headerlink" title="2.1.2 类型转换"></a>2.1.2 类型转换</h3><p>类型转换就是将对象从一种给定的类型<strong>转换（convert）</strong>为另一种相关类型。</p>
<p>当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b=<span class="number">42</span>;<span class="comment">//b为真</span></span><br><span class="line"><span class="keyword">int</span> i=b;<span class="comment">//i的值为1</span></span><br><span class="line">i=<span class="number">3.14</span>;<span class="comment">//i的值为3</span></span><br><span class="line"><span class="keyword">double</span> PI=i;<span class="comment">//PI的值为3.00</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c=<span class="number">-1</span>;<span class="comment">//假设char占8比特，则c的值为255</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2=<span class="number">256</span>;<span class="comment">//假设char占8比特，则c2的值未定义</span></span><br></pre></td></tr></table></figure>
<p>当我们赋给带符号类型一个超过它表示范围的数时，结果是<strong>未定义的(undefined)</strong>,此时，程序可能继续工作，可能崩溃，可能产生垃圾数据。</p>
<h4 id="含有无符号类型的表达式"><a href="#含有无符号类型的表达式" class="headerlink" title="含有无符号类型的表达式"></a>含有无符号类型的表达式</h4><p>当一个算术表达式中既有无符号数又有int类型的数，那么这个int类型的数会被转换成无符号数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsined u=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">-42</span>;</span><br><span class="line">std::cout&lt;&lt;i+i&lt;&lt;std::endl;<span class="comment">//输出-84</span></span><br><span class="line">std::cout&lt;&lt;i+u&lt;&lt;std::endl;<span class="comment">//如果int占32位，则输出4294967264</span></span><br></pre></td></tr></table></figure>
<p>当从无符号数中减去一个值时，无论这个值是不是无符号数，都要确保最后的结构不是一个负数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u1=<span class="number">42</span>,u2=<span class="number">10</span>;</span><br><span class="line">std::cout&lt;&lt;u1-u2&lt;&lt;std::endl;<span class="comment">//正确，输出32</span></span><br><span class="line">std::cout&lt;&lt;u2-u1&lt;&lt;std::endl;<span class="comment">//正确，不过输出的值是取模的结果</span></span><br></pre></td></tr></table></figure>
<p>==注：切勿混用带符号类型和无符号类型==</p>
<h3 id="2-1-3-字面值常量"><a href="#2-1-3-字面值常量" class="headerlink" title="2.1.3 字面值常量"></a>2.1.3 字面值常量</h3><p>一个形如42的值被称为字面值常量（literal），每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。</p>
<h4 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h4><p>我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span><span class="comment">/*十进制数*/</span>	<span class="number">020</span><span class="comment">/*八进制数*/</span>	<span class="number">0x20</span><span class="comment">/*十六进制数*/</span></span><br></pre></td></tr></table></figure>
<p>整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制数是带符号的，而八进制数和十六进制数可能是无符号的，也可能是带符号的。</p>
<p>整型字面值可以被存储在带符号数据类型中。严格来说，整型字面值不可能是负数，如-42中的负号只是对字面值取负值。</p>
<p>浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e来表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14159</span>		<span class="number">3.14159E0</span>		<span class="number">0.</span>		<span class="number">0e0</span>		<span class="number">.001</span></span><br></pre></td></tr></table></figure>
<p>默认的，浮点型字面值是一个double。</p>
<h4 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h4><p>由一对单引号引起来的字符称为char型字面值，由一对双引号引起来的零个或多个字符则构成字符串型字面值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span>				<span class="comment">//字符型字面值</span></span><br><span class="line"><span class="string">&quot;Hello World&quot;</span>	<span class="comment">//字符串型字面值</span></span><br></pre></td></tr></table></figure>
<p>字符串字面值的类型实际上是常量字符构成的<strong>数组（array）</strong>。编译器在每个字符串的结尾加上一个’\0’，因此每个字符串的长度实际上比它的内容多1。</p>
<h4 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h4><p>有两类字符程序员不可以直接使用，一种是 <strong>不可打印（nonprintable）</strong> 的字符，因为它们没有可视的图符，另外一种是在C++中含有特殊含义的字符（单引号、双引号、问好、反斜线）。在这些情况下需要用到<strong>转义序列（escape sequence）</strong>。<br><img src="https://img-blog.csdnimg.cn/20210315204727635.png" alt="转义序列"><br>在程序中，转义序列被当作一个字符。</p>
<p>我们也可使用泛化的转义字符，其形式是\x后跟一个或多个十六进制的数字，或者\后面紧跟1个、2个或3个的八进制数字，其中数字部分表示的是字符对应的数值。<br><img src="https://img-blog.csdnimg.cn/20210315205121766.png" alt="泛化的转义序列"><br>我们也可像只用普通字符一样使用C++定义的转义序列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="string">&quot;Hi \x4dO\115!\n&quot;</span>;<span class="comment">//输出Hi MOM！</span></span><br><span class="line">std::cout&lt;&lt;<span class="string">&#x27;\115&#x27;</span>;<span class="comment">//输出M</span></span><br></pre></td></tr></table></figure>
<p>如果\后面的八进制数超过3个，则只有\和前3个数字构成转义序列，如/1234为转义序列\123对应的字符和字符4。\x则要用到跟在它后面所有的数字（可能会报错）。</p>
<h4 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h4><p>通过添加如下的前缀或后缀，可以改变整型、浮点型和字符型字面值的默认类型。<br><img src="https://img-blog.csdnimg.cn/20210315205751131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70" alt="前缀后缀"></p>
<h4 id="布尔字面值和指针字面值"><a href="#布尔字面值和指针字面值" class="headerlink" title="布尔字面值和指针字面值"></a>布尔字面值和指针字面值</h4><p>true和false是布尔类型的字面值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> test=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>nullptr是指针字面值。<br>————————————————————————————————————————————————————————</p>
<h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><p>变量提供一个具名的，可供程序操作的存储空间。<strong>变量（variable）</strong>和<strong>对象</strong>（<strong>object</strong>，指一块能存储数据并拥有某种类型的内存空间）一般可以互换使用。</p>
<h3 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h3><p>变量定义的基本形式是：首先是<strong>类型说明符（type specifier）</strong>，随后紧跟由一个或多个变量名组成的列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>,value,</span><br><span class="line">	units_sold=<span class="number">0</span>;</span><br><span class="line">Sales_item item;</span><br><span class="line"><span class="comment">//string是一种库类型，表示一个可变长的字符序列</span></span><br><span class="line"><span class="function">std::string <span class="title">book</span><span class="params">(<span class="string">&quot;0-201-78345-X&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h4><p>当对象在创建时获得了一个特定的值，则这个对象被<strong>初始化（initialized）</strong> 了。<br>==注：初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代==</p>
<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> units_sold=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> units_sold=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这种用花括号来初始化变量的形式都叫做<strong>列表初始化（list initialization）</strong>。             </p>
<p>当用于内置类型的变量，列表初始化有一种特点：如果列表初始化且初始值存在丢失信息的风险，则编译器会报错。</p>
<h4 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h4><p>如果定义变量时没有指定初值，那么变量会被<strong>默认初始化（default initialization）</strong> 。</p>
<p> 默认值由变量类型来决定，定义变量的位置也会对此由影响。</p>
<p>如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量将被初始化为0。一种例外情况是，定义在函数体内部的内置类型变量<strong>不被初始化（uninitialized）</strong>。一个不被初始化的内置类型变量的值是未定义的，试图拷贝或以其他方式访问这个值将引起错误。</p>
<p>每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类运行这种行为，它将决定对象的初始值到底是什么。<br>==注：定义于函数体内的内置类型的对象如果没有初始化，其值是未定义的。类的对象如果没有显式地初始化，则其值由类决定==</p>
<h3 id="2-2-2-变量声明和定义的关系"><a href="#2-2-2-变量声明和定义的关系" class="headerlink" title="2.2.2 变量声明和定义的关系"></a>2.2.2 变量声明和定义的关系</h3><p>C++语言支持<strong>分离式编译（separate complication）</strong> 机制 ，该机制允许将程序分割成若干个文件，每个文件可被独立编译。</p>
<p>为了支持分离式编译，C++语言将声明与定义区分开来。<strong>声明（declaration）</strong> 使得名字被程序所知，一个文件如果想用别处所定义的名字则必须包含对那个名字的声明。而<strong>定义（definition）</strong> 负责创建与名字关联的实体。                                    </p>
<p>变量和定义都声明规定了变量的类型和名字，而定义还将为变量申请存储空间，也可能会为变量赋一个初始值。</p>
<p>如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量。</p>
<p>extern语句如果包含初始值就不再是声明，而变成定义了。</p>
<p>变量只能被声明一次，但可以被多次定义。            </p>
<p>如果要在多个文件中使用同一个变量，就必须将声明与定义分离。此时，变量的定义必须出现在且只能出现在同一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p>
<blockquote>
<p>关键概念：静态类型<br>C++是一种<strong>静态类型（statically typed）</strong> 语言，其含义是在编译阶段检查类型。其中，检查类型的过程被称为<strong>类型检查（type checking）</strong>。<br>在C++语言中，编译器负责检查数据类型是否支持要执行的运算。如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。</p>
</blockquote>
<h3 id="2-2-3-标识符"><a href="#2-2-3-标识符" class="headerlink" title="2.2.3 标识符"></a>2.2.3 标识符</h3><p>C++的<strong>标识符（identifier）</strong> 由字母、数字、下划线组成，其中必须以字母或下划线开头，长度没有限制但对大小字母有区分。</p>
<p>用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头。</p>
<h4 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h4><p> <strong>·</strong> 标识符要能体现实际含义。<br> <strong>·</strong> 变量名一般使用小写字母，如index，不要写成Index或INDEX。<br> <strong>·</strong> 用户自定义的类名一般以大写字母开头，如Sales_item。<br> <strong>·</strong> 如果标识符由多个单词组成，则单词间应有明显区分，如student_loan或studentLoan，不要使用studentloan。<br> <img src="https://img-blog.csdnimg.cn/20210318203914743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDQ3NTA3Mw==,size_16,color_FFFFFF,t_70" alt="C++关键字和操作符替代名"></p>
<h4 id="2-2-4-名字的作用域"><a href="#2-2-4-名字的作用域" class="headerlink" title="2.2.4 名字的作用域"></a>2.2.4 名字的作用域</h4><p><strong>作用域（scope）</strong> 是程序的一部分，C++语言中大多数作用域都以花括号分隔。</p>
<p>同一个名字在不同的作用域可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端作为结束。</p>
<p>主函数main定义在所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥有<strong>全局作用域（global scope）</strong>。函数体内的变量具有<strong>块作用域（block scope）</strong>。</p>
<h4 id="嵌套的作用域"><a href="#嵌套的作用域" class="headerlink" title="嵌套的作用域"></a>嵌套的作用域</h4><p>作用域能彼此包含，被包含（或被嵌套）的作用域称为<strong>内层作用域（inner scope）</strong>，包含着别的作用域的作用域被称为<strong>外层作用域（outer scope）</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量</span></span><br><span class="line"><span class="keyword">int</span> reused = <span class="number">42</span>;<span class="comment">//reused拥有全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> unique = <span class="number">0</span>;<span class="comment">//unique拥有块作用域</span></span><br><span class="line">	<span class="comment">//输出#1：使用全局变量reused；输出 42 0</span></span><br><span class="line">	std::cout&lt;&lt;reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unique&lt;&lt;std::endl;</span><br><span class="line">	<span class="keyword">int</span> reused = <span class="number">0</span>;<span class="comment">//新建局部变量reused，覆盖了全局变量reused</span></span><br><span class="line">	<span class="comment">//输出#2：使用局部变量reused;输出 0 0</span></span><br><span class="line">	std::cout&lt;&lt;reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unique&lt;&lt;std::endl;</span><br><span class="line">	<span class="comment">//输出#3：显式地访问全局变量reused;输出 42 0</span></span><br><span class="line">	std::cout&lt;&lt;::reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unique&lt;&lt;std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==注：如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量==<br>————————————————————————————————————————————————————————</p>
<h2 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h2><p><strong>复合类型（compound type）</strong> 是指基于其他类型定义地类型。C++语言由几种复合类型，如引用和指针。</p>
<p>一条声明语句由一个<strong>基本数据类型（base type）</strong> 和紧随其后的一个<strong>声明符（declarator）</strong> 列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p>
<h3 id="2-3-1-引用"><a href="#2-3-1-引用" class="headerlink" title="2.3.1 引用"></a>2.3.1 引用</h3><p><strong>引用（reference，通常指的是左值引用）</strong> 为对象起了另一个名字，引用类型引用另一种类型，通过将声明符写成&amp;d的形式来引用另一种类型，其中d是声明的变量名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal=ival;<span class="comment">//refVal指向ival（refVal是ival的别名）</span></span><br><span class="line"><span class="keyword">int</span> refVal2;<span class="comment">//报错，引用必须初始化</span></span><br></pre></td></tr></table></figure>
<p>程序把引用和它的初始值<strong>绑定（bind）</strong> 在一起，而不是将初始值拷贝给引用，无法令引用绑定到另外一个对象。</p>
<p>引用本身不是一个对象，所以不能定义引用的引用。</p>
<h4 id="引用的定义"><a href="#引用的定义" class="headerlink" title="引用的定义"></a>引用的定义</h4><p>允许在一条语句中定义多个引用，每个引用标识符都必须以&amp;符号开头。</p>
<p>引用只能绑定在对象上，不能与字面值或者某个表达式的计算结果绑定在一起。</p>
<h3 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h3><p><strong>指针（pointer）</strong> 是指向另一种类型的复合类型。</p>
<p>指针本身就是一个对象，允许对指针进行赋值或者拷贝。在指针的生命周期内它可以指向多个不同的对象。指针可以不在定义时赋初值。</p>
<p>定义指针的方法是将声明符写成*d的形式，其中d是变量名。允许在一个语句中定义多个指针，每个指针变量名前必须以 * 符号开头。</p>
<h4 id="获取对象的指针"><a href="#获取对象的指针" class="headerlink" title="获取对象的指针"></a>获取对象的指针</h4><p>指针存放某个对象的地址，要想获取这个地址，必须使用<strong>取地址符（&amp;）</strong>。</p>
<p>引用不是对象，所以不能定义指向引用的指针。</p>
<p>一般情况下，指针的类型要与它指向对象的类型一致。</p>
<h4 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h4><p>指针的值（即地址）应属下列4种状态之一：<br>1.指向一个对象；<br>2.指向紧邻对象所占的下一个位置；<br>3.空指针，意味着指针没有指向任何位置；<br>4.无效指针，也就是上述情况之外的其他值。</p>
<p>试图访问或拷贝无效指针的值都将引发错误，访问无效指针的后果无法预计。</p>
<p>访问第二种和第三种指针的对象行为不被允许，后果也无法预计。</p>
<h5 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h5><p>如果指针指向了一个对象，则允许用<strong>解引用符（操作符 * ）</strong> 来访问该对象。</p>
<p>对指针解引用会得到指针所指向的对象，因此给解引用的结果赋值，实际上就是给指针所指向的对象赋值。</p>
<blockquote>
<p><strong>关键概念：某些符号有多重含义：</strong><br>像&amp;和<em>这样的符号，既能用作表达式的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义。<br>在声明语句种，&amp;和</em>用于构造复合类型，在表达式中，它们又转变为运算符。</p>
</blockquote>
<h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p><strong>空指针（null pointer）</strong> 不指向任何对象。几个生成空指针的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1=<span class="literal">nullptr</span>;	<span class="comment">//等价于int *p1=0</span></span><br><span class="line"><span class="keyword">int</span> *p2=<span class="number">0</span>;			<span class="comment">//直接将p2初始化为字面值常量0</span></span><br><span class="line"><span class="keyword">int</span> *p3=<span class="literal">NULL</span>;		<span class="comment">//等价于int *p3=0；</span></span><br></pre></td></tr></table></figure>
<p>得到空指针最直接的办法是用字面值<strong>nullptr</strong>来初始化指针。nullptr是一种特殊类型的字面值，它可被转换成任意其他的指针类型。</p>
<p>过去的程序还会用到一个名叫NULL的<strong>预处理变量（preprocessor variable）</strong> 来给指针赋值，这个变量在头文件cstdlib种定义，它的值是0。预处理变量不属于命名空间std，它由预处理器负责管理。</p>
<p>==注：现在的C++程序最好使用nullptr，同时尽量避免使用NULL==</p>
<p>把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。</p>
<blockquote>
<p><strong>建议：初始化所有指针</strong><br>使用未经初始化的指针是引发运行时错误的一大原因，访问未经初始化指针所引发的后果也是无法预计。<br>如果使用未经初始化的指针，相当于访问一个本不存在的位置上的本不存在的对象，若指针所占内存空间中恰好由内容，而这些内容又被当作了某个地址，我们很难分清它到底是合法的还是非法的。<br>如果实在不清楚指针应该指向哪里，就把它初始化为nullptr或0。</p>
</blockquote>
<h4 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h4><p>给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。</p>
<h4 id="其他指针操作"><a href="#其他指针操作" class="headerlink" title="其他指针操作"></a>其他指针操作</h4><p>只要指针拥有一个合法值，就能将它用在条件表达式中。任何非0指针对应的条件值都是true。</p>
<p>对于两个类型相同的合法指针，可以用相等操作符（==）或不相等操作符（！=）来比较它们，比较的结果是布尔类型。</p>
<h4 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h4><p><strong>void</strong>*是一种特殊的指针类型，可用于存放不论类型的任意对象的地址。</p>
<p>利用void<em>指针能做的事比较有限：拿它和别的指针比较、作为函数的输入输出，或者赋给另外一个void</em>指针。不能直接操作void*指针所指的对象。</p>
<h3 id="2-3-3-理解复合类型的声明"><a href="#2-3-3-理解复合类型的声明" class="headerlink" title="2.3.3 理解复合类型的声明"></a>2.3.3 理解复合类型的声明</h3><p>在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。这意味着同一条定义语句可能定义出不同类型的变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i是一个int型的数，p是一个int型指针，r是一个int型引用</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1024</span>,*p=&amp;i,&amp;r=i;</span><br></pre></td></tr></table></figure>
<h4 id="定义多个变量"><a href="#定义多个变量" class="headerlink" title="定义多个变量"></a>定义多个变量</h4><p>涉及指针或引用的声明一般有两种写法，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种，声明符跟着基本数据类型</span></span><br><span class="line"><span class="keyword">int</span>* p1,p2;</span><br><span class="line"><span class="comment">//第二种，声明符跟着变量名</span></span><br><span class="line"><span class="keyword">int</span> *p1,p2;</span><br></pre></td></tr></table></figure>
<p>第一种写法容易让人误会，认为p1,p2都是int型的指针，但实际上只有p1是int型指针，而p2只是int型的值。</p>
<h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p>指针是内存中的对象，允许把指针的地址再放到另一个指针当中。</p>
<p>通过*的个数可以区分指针的级别。</p>
<p>解引用指向指针的指针会得到一个指针，这意味着要访问最原始的那个对象，需要对指针的指针做两次解引用。</p>
<h4 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;			<span class="comment">//p是一个int型指针</span></span><br><span class="line"><span class="keyword">int</span> *&amp;r=p;		<span class="comment">//r是一个对指针p的引用</span></span><br></pre></td></tr></table></figure>
<p>————————————————————————————————————————————————————————</p>
<h2 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h2><p>当我们希望定义一种值不能改变的变量时，可以用关键字<strong>const</strong>对变量的类型将以限定:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufSize=<span class="number">512</span>;	<span class="comment">//正确</span></span><br><span class="line">bufSize =<span class="number">1024</span>;			<span class="comment">//错误：试图向const对象写值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k;			<span class="comment">//错误：const对象必须初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="初始化和const"><a href="#初始化和const" class="headerlink" title="初始化和const"></a>初始化和const</h4><p>const类型最主要的限制是只能在其类型的对象上执行不改变其内容的操作。</p>
<p>在不改变const对象的操作中有一种是初始化，如果利用一个对象去初始化另外一个对象，则是不是const都无关紧要。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=i;		<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> j=ci;			<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<h4 id="默认状态下，const对象仅在文件内有效"><a href="#默认状态下，const对象仅在文件内有效" class="headerlink" title="默认状态下，const对象仅在文件内有效"></a>默认状态下，const对象仅在文件内有效</h4><p>有些时候我们想只在一个文件中定义const，而在其他多个文件中声明并使用它。解决方法是对于const变量不管是声明还是定义都添加<strong>extern</strong>关键字，这样只需定义一次就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;</span><br></pre></td></tr></table></figure>
<p>extern的作用是指明这个变量并非本文件定义使其被其他文件使用。</p>
<h3 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1 const的引用"></a>2.4.1 const的引用</h3><p>可以把引用绑定在const对象上，我们称之为<strong>对常量的引用（reference to const）</strong>，对常量的引用不能被用作修改它所绑定的对象。</p>
<blockquote>
<p><strong>术语：常量引用是对const的引用</strong><br>C++程序员经常把“对const的引用”简称为“常量引用”（实际上并不存在常量引用）。</p>
</blockquote>
<h4 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h4><p>通常引用的类型必须与其所引用对象的类型一致，两种情况例外。</p>
<p>第一种例外情况是在初始化常量引用时允许用任意表达式作为初始值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=i;		<span class="comment">//允许将一个const int&amp;绑定到一个普通int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2=<span class="number">42</span>;		<span class="comment">//正确，r2是一个常量引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3=r1*<span class="number">2</span>;		<span class="comment">//正确，r3是一个常量引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4=r1*<span class="number">2</span>;			<span class="comment">//错误，r4是一个普通的非常量引用</span></span><br></pre></td></tr></table></figure>
<p>当一个常量引用被绑定到另外一种类型上时，编译器会创建一个<strong>临时量（temporary）</strong> 对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri=dval;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译器会优化成：</span></span><br><span class="line"><span class="comment">double dval=3.14;</span></span><br><span class="line"><span class="comment">const int temp=dval;</span></span><br><span class="line"><span class="comment">const int &amp;ri=temp;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="headerlink" title="对const的引用可能引用一个并非const的对象"></a>对const的引用可能引用一个并非const的对象</h4><p>常量引用仅对引用可参与的操作进行了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值。</p>
<h3 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h3><p>与引用一样，也可以令指针指向常量或非常量，指向常量的指针（pointer to const）不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的地址。</p>
<p>和常量引用相似，通常情况指针的类型必须与其所指对象的类型一样，但是有两个例外。</p>
<p>第一种例外时允许令一个指向常量的指针指向一个非常量对象。</p>
<h4 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h4><p>常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（即存放在指针中的那个地址）就不能再改变了。</p>
<p>把*放在const关键字之前用以说明指针是一个常量，注意不变的时指针本身的值而不是指向的那个值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr=&amp;errNumb		<span class="comment">//curErr将一直指向errNumb;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip=&amp;pi;	<span class="comment">//pip时一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure>
<p>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。</p>
<h3 id="2-4-3-顶层const"><a href="#2-4-3-顶层const" class="headerlink" title="2.4.3 顶层const"></a>2.4.3 顶层const</h3><p>指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词<strong>顶层const（top-level const）</strong> 表示指针本身是个常量，而用名词<strong>底层const（low-level const）</strong> 表示指针所指的对象是一个常量。</p>
<p>指针类型既可以是顶层const也可以是底层const。</p>
<p>底层const的限制不能忽视，当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。</p>
<h3 id="2-4-4-constexpr和常量表达式"><a href="#2-4-4-constexpr和常量表达式" class="headerlink" title="2.4.4 constexpr和常量表达式"></a>2.4.4 constexpr和常量表达式</h3><p><strong>常量表达式（const expression）</strong> 是指值不会改变并且在编译过程就能得到计算结果的表达式。用常量表达式初始化的const对象也是常量表达式。</p>
<p>一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_files=<span class="number">20</span>;			<span class="comment">//max_files是常量表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit=max_files+<span class="number">1</span>;	<span class="comment">//limit是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> staff_size=<span class="number">27</span>;				<span class="comment">//staff_size不是常量表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz=<span class="built_in">get_size</span>();		<span class="comment">//sz不是常量表达式</span></span><br></pre></td></tr></table></figure>
<p>尽管sz本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。</p>
<h4 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h4><p>C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf=<span class="number">20</span>;		<span class="comment">//20是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit=mf+<span class="number">1</span>;	<span class="comment">//mf+1是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz=<span class="built_in">size</span>();	<span class="comment">//只有当size是一个constexpr函数时才是一条正确的声明语句</span></span><br></pre></td></tr></table></figure>
<p>新标准允许定义一种特殊的constexpr函数。</p>
<blockquote>
<p>一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。</p>
</blockquote>
<h4 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h4><p>声明constexpr时用到的类型被称为 <strong>“字面值类型”（literal type）</strong>。</p>
<p>算术类型、引用和指针都属于字面值类型。自定义类、IO库、string类型则不属于字面值类型。</p>
<p>指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址的对象。</p>
<p>函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反地，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。</p>
<p>允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。</p>
<h4 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和constexpr</h4><p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。</p>
<p>constexpr指针既可以指向常量也可以指向一个非常量。</p>
<p>————————————————————————————————————————————————————————</p>
<h2 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h2><h3 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h3><p><strong>类型别名（type alias）</strong> 是一个名字，它是某种类型的同义词。</p>
<p>有两种方法可用于定义类型别名。传统的方法是使用关键字<strong>typedef</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;	<span class="comment">//wage是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base,*p;	<span class="comment">//base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure>
<p>关键字typedef作为声明语句中的i基本数据类型的一部分出现。</p>
<p>新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI=Sales_item;	<span class="comment">//SI是Sales_item的同义词</span></span><br></pre></td></tr></table></figure>
<p>这种方法用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。</p>
<h4 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr=<span class="number">0</span>;	<span class="comment">//cstr是指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps;	<span class="comment">//ps是一个指针，它的对象是指向char的常量指针</span></span><br><span class="line"><span class="comment">//下面是错误理解</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr=<span class="number">0</span>;<span class="comment">//对const pstring cstr的错误理解</span></span><br></pre></td></tr></table></figure>
<p>声明语句中用到pstring时，其基本数据类型是指针。可是错误理解里基本数据类型是const char。前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。</p>
<h3 id="2-5-3-auto类型说明符"><a href="#2-5-3-auto类型说明符" class="headerlink" title="2.5.3 auto类型说明符"></a>2.5.3 auto类型说明符</h3><p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值。</p>
<p>使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i=<span class="number">0</span>,*p=&amp;i;			<span class="comment">//正确：i是整数，p是整数指针</span></span><br><span class="line"><span class="keyword">auto</span> size=<span class="number">0</span>,pi=<span class="number">3.14</span>;	<span class="comment">//错误：sz和pi的类型不一致</span></span><br></pre></td></tr></table></figure>
<h4 id="复合类型、常量和auto"><a href="#复合类型、常量和auto" class="headerlink" title="复合类型、常量和auto"></a>复合类型、常量和auto</h4><p>编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。</p>
<p>首先，当引用被用作初始值时，编译器以引用对象的类型作为auto的类型。</p>
<p>其次，auto一般会忽略掉顶层const，同时底层const则会保留下来。</p>
<p>如果希望推断出的auto类型是一个顶层const，需要明确指出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f=ci;	<span class="comment">//ci的推演类型是int，f是const int</span></span><br></pre></td></tr></table></figure>
<p>还可以将引用的类型设为auto，此时原来的初始化规则则仍然适用。</p>
<p>要在一条语句中定义多个变量，切记，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型。</p>
<h3 id="2-5-3-decltype类型指示符"><a href="#2-5-3-decltype类型指示符" class="headerlink" title="2.5.3 decltype类型指示符"></a>2.5.3 decltype类型指示符</h3><p>C++11新标准引入了第二种类型说明符<strong>decltype</strong>，它的作用是选择并返回操作数的数据类型。</p>
<p>在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值，编译器也并不实际调用函数，而是得到当调用发生时函数的返回值类型。</p>
<p>如果decltype使用的表达式时一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）。</p>
<p>引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。</p>
<h4 id="decltype和引用"><a href="#decltype和引用" class="headerlink" title="decltype和引用"></a>decltype和引用</h4><p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。有些表达式将向decytype返回一个引用类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//decltype的结果可以是引用类型</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>,*p=&amp;i,&amp;r=i;</span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b;	<span class="comment">//正确：加法的结果是int，因此b是一个未初始化的int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;		<span class="comment">//错误：c是int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure>
<p>如果表达式的内容是解引用操作，则decltype将得到引用类型。</p>
<p>对于decltype使用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的时一个不加括号的变量，则得到的结果就是该变量的类型。如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//decltype的表达式如果是加上了括号的变量，结果将是引用</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d;	<span class="comment">//错误：d是int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;		<span class="comment">//正确：e是一个未初始化的int</span></span><br></pre></td></tr></table></figure>
<p>==注：decltype（（variable））的结果永远是引用，而decltype（variable）结果只有当variable本身就是一个引用时才是引用==</p>
<p>————————————————————————————————————————————————————————</p>
<h2 id="2-6-自定义数据结构"><a href="#2-6-自定义数据结构" class="headerlink" title="2.6 自定义数据结构"></a>2.6 自定义数据结构</h2><p>从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。</p>
<p>C++语言允许用户以类的形式自定义数据类型，而库类型string、istream、ostream等也都是以类的形式定义的。</p>
<h3 id="2-6-1-定义Sales-data类型"><a href="#2-6-1-定义Sales-data类型" class="headerlink" title="2.6.1 定义Sales_data类型"></a>2.6.1 定义Sales_data类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">	std::string bookNo;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> revenue=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们的类以关键字<strong>struct</strong>开始，紧跟着类名和类体（其中类体部分可以为空）。</p>
<p>类体由花括号包围形成了一个新的作用域。类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。</p>
<p>类体右侧的表示结束的花括号必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少。</p>
<p>一般来说，最好不要把对象的定义和类的定义放在一起。</p>
<h4 id="类数据成员"><a href="#类数据成员" class="headerlink" title="类数据成员"></a>类数据成员</h4><p>类体定义类的成员，我们的类只有<strong>数据成员（data member）</strong>。类的数据成员定义了类的对象的具体内容。</p>
<p>定义数据成员的方法和定义普通变量一样。</p>
<p>C++新标准规定，可以为数据成员提供一个<strong>类内初始值（in-class initialize）</strong>。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将默认初始化。</p>
<p>用户可以使用C++语言提供的另外一个关键字<strong>class</strong>来定义自己的数据结构。</p>
<h3 id="2-6-2-使用Sales-data类"><a href="#2-6-2-使用Sales-data类" class="headerlink" title="2.6.2 使用Sales_data类"></a>2.6.2 使用Sales_data类</h3><h4 id="添加两个Sales-data对象"><a href="#添加两个Sales-data对象" class="headerlink" title="添加两个Sales_data对象"></a>添加两个Sales_data对象</h4><h4 id="Sales-data对象读入数据"><a href="#Sales-data对象读入数据" class="headerlink" title="Sales_data对象读入数据"></a>Sales_data对象读入数据</h4><h4 id="输出两个Sale-data对象的和"><a href="#输出两个Sale-data对象的和" class="headerlink" title="输出两个Sale_data对象的和"></a>输出两个Sale_data对象的和</h4><h3 id="2-6-3-编写自己的头文件"><a href="#2-6-3-编写自己的头文件" class="headerlink" title="2.6.3 编写自己的头文件"></a>2.6.3 编写自己的头文件</h3><p>类一般都不定义在函数体内。当在函数体外部定义类时，在各个指定的源文件中可能只有一处该类的定义。而且，如果要在不同文件中使用同一个类，类的定义就必须保持一致。</p>
<p>为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。</p>
<p>头文件通常包含那些只能被定义一次的实体，如类、cosnt和constexpr对象。</p>
<h4 id="预处理器概述"><a href="#预处理器概述" class="headerlink" title="预处理器概述"></a>预处理器概述</h4><p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器（preprocessor）</strong>。预处理器是在编译之前执行的一段代码，可以部分地改变我们所写地程序，如预处理功能 <strong>#include</strong>。</p>
<p>C++程序还会用到地一项预处理功能是<strong>头文件保护符（header guard）</strong>，头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。**#define<strong>指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定地预处理变量是否已经定义：</strong>#ifdef<strong>当且仅当变量已定义时为真，</strong>#ifndef**当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到 <strong>#endif</strong>指令为止。</p>
<p>使用这些功能就能有效地防止重复包含地发生：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">	std::string bookNo;</span><br><span class="line">	<span class="keyword">unsigned</span> unit_sold=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> revenue=<span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>==注：预处理变量无视C++语言中关于作用域地规则。==<br>整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。<br>==注：头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性地加上就可以了，没必须太在乎你的程序到底需不需要。==</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">天了噜Rex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/17/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">http://example.com/2021/11/17/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/17/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">《C++Primer》学习笔记_第三章 字符串、向量和数组.md</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/17/%E3%80%8AC++%20Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%BC%80%E5%A7%8B/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">《C++ Primer》学习笔记_第一章 开始</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">天了噜Rex</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">24</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Phantasm-of-Observer"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">某王姓男子的杂物堆（个人博客），欢迎各位来访！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">第二章 变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">2.1 基本内置类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">2.1.1 算术类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">带符号类型和无符号类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.1.2 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">含有无符号类型的表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">2.1.3 字面值常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E5%92%8C%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">整型和浮点型字面值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">字符和字符串字面值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">转义序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%AD%97%E9%9D%A2%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">指定字面值的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%AD%97%E9%9D%A2%E5%80%BC%E5%92%8C%E6%8C%87%E9%92%88%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">布尔字面值和指针字面值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2.2 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.2.1 变量定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">初始值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">列表初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">默认初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2.2 变量声明和定义的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.2.3 标识符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">变量命名规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E5%90%8D%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.2.4 名字的作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">嵌套的作用域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">2.3 复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.3.1 引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">引用的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E6%8C%87%E9%92%88"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.3.2 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">获取对象的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%80%BC"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">指针值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">利用指针访问对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">空指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">赋值和指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">其他指针操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-%E6%8C%87%E9%92%88"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">void* 指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E7%90%86%E8%A7%A3%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.3.3 理解复合类型的声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">定义多个变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">指向指针的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">指向指针的引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-const%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">2.4 const限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8Cconst"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">初始化和const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%8A%B6%E6%80%81%E4%B8%8B%EF%BC%8Cconst%E5%AF%B9%E8%B1%A1%E4%BB%85%E5%9C%A8%E6%96%87%E4%BB%B6%E5%86%85%E6%9C%89%E6%95%88"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">默认状态下，const对象仅在文件内有效</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-const%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">2.4.1 const的引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%AF%B9const%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">初始化和对const的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9const%E7%9A%84%E5%BC%95%E7%94%A8%E5%8F%AF%E8%83%BD%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%B9%B6%E9%9D%9Econst%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">对const的引用可能引用一个并非const的对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E6%8C%87%E9%92%88%E5%92%8Cconst"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.4.2 指针和const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E6%8C%87%E9%92%88"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">const指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E9%A1%B6%E5%B1%82const"><span class="toc-number">1.4.3.</span> <span class="toc-text">2.4.3 顶层const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-constexpr%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">2.4.4 constexpr和常量表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">constexpr变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">字面值类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8Cconstexpr"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">指针和constexpr</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">2.5 处理类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">1.5.1.</span> <span class="toc-text">2.5.1 类型别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E3%80%81%E5%B8%B8%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">指针、常量和类型别名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.5.3 auto类型说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E3%80%81%E5%B8%B8%E9%87%8F%E5%92%8Cauto"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">复合类型、常量和auto</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">1.5.3.</span> <span class="toc-text">2.5.3 decltype类型指示符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">decltype和引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.</span> <span class="toc-text">2.6 自定义数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-%E5%AE%9A%E4%B9%89Sales-data%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">2.6.1 定义Sales_data类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">类数据成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E4%BD%BF%E7%94%A8Sales-data%E7%B1%BB"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.6.2 使用Sales_data类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%A4%E4%B8%AASales-data%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">添加两个Sales_data对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sales-data%E5%AF%B9%E8%B1%A1%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">Sales_data对象读入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%B8%A4%E4%B8%AASale-data%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%92%8C"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">输出两个Sale_data对象的和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-3-%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.3.</span> <span class="toc-text">2.6.3 编写自己的头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">预处理器概述</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/%5BSubstrate%20Recipes%E7%BF%BB%E8%AF%91%5D1.21%20Tightly-%20and%20Loosely-Coupled%20Pallets/" title="&lt;Substrate Recipes翻译&gt;1.21 Tightly- and Loosely-Coupled Pallets"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="&lt;Substrate Recipes翻译&gt;1.21 Tightly- and Loosely-Coupled Pallets"/></a><div class="content"><a class="title" href="/2021/11/17/%5BSubstrate%20Recipes%E7%BF%BB%E8%AF%91%5D1.21%20Tightly-%20and%20Loosely-Coupled%20Pallets/" title="&lt;Substrate Recipes翻译&gt;1.21 Tightly- and Loosely-Coupled Pallets">&lt;Substrate Recipes翻译&gt;1.21 Tightly- and Loosely-Coupled Pallets</a><time datetime="2021-11-17T12:46:48.000Z" title="Created 2021-11-17 20:46:48">2021-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/%E3%80%8ARust%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%BE%85%E6%9B%B4%E6%96%B0/" title="《Rust权威指南》学习笔记_待更新"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Rust权威指南》学习笔记_待更新"/></a><div class="content"><a class="title" href="/2021/11/17/%E3%80%8ARust%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%BE%85%E6%9B%B4%E6%96%B0/" title="《Rust权威指南》学习笔记_待更新">《Rust权威指南》学习笔记_待更新</a><time datetime="2021-11-17T12:40:53.000Z" title="Created 2021-11-17 20:40:53">2021-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC11%E7%AB%A0%20%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/" title="《Python编程：从入门到实践》学习笔记_第11章 测试代码"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Python编程：从入门到实践》学习笔记_第11章 测试代码"/></a><div class="content"><a class="title" href="/2021/11/17/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC11%E7%AB%A0%20%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/" title="《Python编程：从入门到实践》学习笔记_第11章 测试代码">《Python编程：从入门到实践》学习笔记_第11章 测试代码</a><time datetime="2021-11-17T12:39:44.000Z" title="Created 2021-11-17 20:39:44">2021-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC10%E7%AB%A0%20%E6%96%87%E4%BB%B6%E5%92%8C%E5%BC%82%E5%B8%B8/" title="《Python编程：从入门到实践》学习笔记_第10章 文件和异常"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Python编程：从入门到实践》学习笔记_第10章 文件和异常"/></a><div class="content"><a class="title" href="/2021/11/17/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC10%E7%AB%A0%20%E6%96%87%E4%BB%B6%E5%92%8C%E5%BC%82%E5%B8%B8/" title="《Python编程：从入门到实践》学习笔记_第10章 文件和异常">《Python编程：从入门到实践》学习笔记_第10章 文件和异常</a><time datetime="2021-11-17T12:39:05.000Z" title="Created 2021-11-17 20:39:05">2021-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC9%E7%AB%A0%20%E7%B1%BB/" title="《Python编程：从入门到实践》学习笔记_第9章 类"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《Python编程：从入门到实践》学习笔记_第9章 类"/></a><div class="content"><a class="title" href="/2021/11/17/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AC%AC9%E7%AB%A0%20%E7%B1%BB/" title="《Python编程：从入门到实践》学习笔记_第9章 类">《Python编程：从入门到实践》学习笔记_第9章 类</a><time datetime="2021-11-17T12:38:28.000Z" title="Created 2021-11-17 20:38:28">2021-11-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 天了噜Rex</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>